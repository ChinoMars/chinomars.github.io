<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chino&#39;s Studio</title>
  
  
  <link href="https://chinomars.com/atom.xml" rel="self"/>
  
  <link href="https://chinomars.com/"/>
  <updated>2025-04-20T12:44:47.807Z</updated>
  <id>https://chinomars.com/</id>
  
  <author>
    <name>Chino Mars</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LLVM Backend Practices - Part 1</title>
    <link href="https://chinomars.com/2025/04/15/llvm-backend-practices-1/"/>
    <id>https://chinomars.com/2025/04/15/llvm-backend-practices-1/</id>
    <published>2025-04-15T07:48:57.000Z</published>
    <updated>2025-04-20T12:44:47.807Z</updated>
    
    <content type="html"><![CDATA[<!-- - ～～postencoder～～- ～～shrink～～- ～～inline asm/ptx implementation～～- register definition  - lanemask length limitation for subregister definition  - register pressure calculation- ILP scheduler- fence setting- instruction definition notice: modifier or opcode --><h1 id="LLVM-Backend-Practices-Part-1"><a href="#LLVM-Backend-Practices-Part-1" class="headerlink" title="LLVM Backend Practices - Part 1"></a>LLVM Backend Practices - Part 1</h1><h2 id="Register-definition"><a href="#Register-definition" class="headerlink" title="Register definition"></a>Register definition</h2><p>寄存器定义方面，目前想到这几点：</p><ul><li>lanebitmask length limitation for subregister definition</li><li>register pressure calculation</li></ul><h3 id="What-is-“LaneBitmask”"><a href="#What-is-“LaneBitmask”" class="headerlink" title="What is “LaneBitmask”"></a>What is “LaneBitmask”</h3><p>llvm中使用LaneBitmask来表示一个物理寄存器的subregister的占用情况。</p><h2 id="PostEncoderMethod"><a href="#PostEncoderMethod" class="headerlink" title="PostEncoderMethod"></a>PostEncoderMethod</h2><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>一般情况下我们对于指令encoding采取传统的在指令定义的tablegen文件里，设置好指令的field mapping即可，如果新一代指令集有新指令，则定义新的Inst和fieldmap类即可。</p><p>在实际项目中，我们遇到过这种情况：架构演进过程中，每代之间指令功能变动不大，但指令encoding变动频繁，此外encoding采取的并不是顺序编码，而是逐bit的映射，目的是为了获取一定的指令shrink机会，即可变长指令。这里先不展开讨论shrink，而是着重讨论我们是如何解决encoding问题的。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>解决方案整体上可以一句话概括：自动代码生成 + LLVM基础设施中的PostencodeMethod hook</p><h4 id="Code-Auto-gen"><a href="#Code-Auto-gen" class="headerlink" title="Code Auto-gen"></a>Code Auto-gen</h4><ol><li><p>针对每一代架构指令集，定义一张大表，可以是csv表格或其他便于非研发人员编辑与研发人员读取的格式均可，这个表格中定义每一个指令field对应encoding的比特位序列。</p></li><li><p>读取表格，针对每一类相同编码规则的指令，自动生成形似下述代码的encoder methods。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">XXXInst1PostEncoder</span><span class="params">(<span class="type">const</span> MCInst &amp;MI, <span class="type">unsigned</span> EncodedValue, <span class="type">const</span> MCSubtargetInfo &amp;STI)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// code to transform EncodedValue</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EncodedValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">XXXInst2PostEncoder</span><span class="params">(<span class="type">const</span> MCInst &amp;MI, <span class="type">unsigned</span> EncodedValue, <span class="type">const</span> MCSubtargetInfo &amp;STI)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// code to transform EncodedValue</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EncodedValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// other post encoder methods</span></span><br></pre></td></tr></table></figure><h4 id="LLVM-Infrastrcture-PostEncoderMethod"><a href="#LLVM-Infrastrcture-PostEncoderMethod" class="headerlink" title="LLVM Infrastrcture - PostEncoderMethod"></a>LLVM Infrastrcture - PostEncoderMethod</h4><p>LLVM tablegen类<code>Instruction</code>中包含成员<code>PostEncoderMethod</code>，对需要使用postencoder的指令类绑定相应的method，即可完成绑定，例如ARM架构中的类似代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NDataI</span>&lt;dag oops, dag iops, Format f, InstrItinClass itin,</span><br><span class="line">             string opc, string dt, string <span class="keyword">asm</span>, string cstr, list&lt;dag&gt; pattern&gt;</span><br><span class="line">  : NeonI&lt;oops, iops, AddrModeNone, IndexModeNone, f, itin, opc, dt, <span class="keyword">asm</span>, cstr,</span><br><span class="line">          pattern&gt; &#123;</span><br><span class="line">  let Inst&#123;<span class="number">31</span><span class="number">-25</span>&#125; = <span class="number">0b1111001</span>;</span><br><span class="line">  let PostEncoderMethod = <span class="string">&quot;NEONThumb2DataIPostEncoder&quot;</span>;</span><br><span class="line">  let DecoderNamespace = <span class="string">&quot;NEONData&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为<code>NDataI</code>这类指令，绑定了一个Post encoder method，用于在code emitting时对encoding进行修改。</p><h2 id="Shrink"><a href="#Shrink" class="headerlink" title="Shrink"></a>Shrink</h2><p>Shrink操作并不少见，很多可变长指令集都有对encoding的shrink操作，即在指令编码阶段，根据指令集编码的定义，允许按照一定规则将指令编码进一步缩短。根据指令集特点，会有不同的shrink策略。当然也有一些架构代码中定义了类似shrink的pass，会做一些target specific的指令替换或立即数优化，这与我们工作中遇到的shrink不相同，以下会称之为“某架构”。</p><p>某架构最长支持128bit，最短32bit编码，指令各个field根据一些经验和profiler数据，将编码的bit位分布在不同的dword上，并且会给这些域定义一个缺省值，这样就可以根据128bit中4个dword的u32值来判断某条指令实际是否会占据更高32bit的bit位，从而帮助编译器判断是否可以做shrink。</p><p>根据以上描述，编译器会根据某条指令初始编码中的4个u32值，是否为默认值，来判断最短可以shrink到几个dword，并且在实际占据的若干个dword的最后一个的最后一位上，设置一个endbit，即简单设为1，舍去后续的encoding，即可完成shrink。</p><h2 id="Inlined-ptx-asm-Impl"><a href="#Inlined-ptx-asm-Impl" class="headerlink" title="Inlined ptx&#x2F;asm Impl"></a>Inlined ptx&#x2F;asm Impl</h2><p>llvm有支持inline对应架构的asm汇编的基础设施，具体是定义一个继承<code>MCAsmInfo</code>类，做一些简单的配置和注册即可初步使能inline asm，当然前提是指令定义是tablegen中要定义好每个指令对应的汇编格式。以AMDGPU为例：</p><ul><li>定义并配置<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definition and configurations</span></span><br><span class="line">AMDGPUMCAsmInfo::<span class="built_in">AMDGPUMCAsmInfo</span>(<span class="type">const</span> Triple &amp;TT,</span><br><span class="line">                                 <span class="type">const</span> MCTargetOptions &amp;Options) &#123;</span><br><span class="line">  CodePointerSize = (TT.<span class="built_in">getArch</span>() == Triple::amdgcn) ? <span class="number">8</span> : <span class="number">4</span>;</span><br><span class="line">  StackGrowsUp = <span class="literal">true</span>;</span><br><span class="line">  HasSingleParameterDotFile = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//===------------------------------------------------------------------===//</span></span><br><span class="line">  MinInstAlignment = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is the maximum instruction encoded size for gfx10. With a known</span></span><br><span class="line">  <span class="comment">// subtarget, it can be reduced to 8 bytes.</span></span><br><span class="line">  MaxInstLength = (TT.<span class="built_in">getArch</span>() == Triple::amdgcn) ? <span class="number">20</span> : <span class="number">16</span>;</span><br><span class="line">  SeparatorString = <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  CommentString = <span class="string">&quot;;&quot;</span>;</span><br><span class="line">  InlineAsmStart = <span class="string">&quot;;#ASMSTART&quot;</span>;</span><br><span class="line">  InlineAsmEnd = <span class="string">&quot;;#ASMEND&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//===--- Data Emission Directives -------------------------------------===//</span></span><br><span class="line">  UsesELFSectionDirectiveForBSS = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//===--- Global Variable Emission Directives --------------------------===//</span></span><br><span class="line">  HasAggressiveSymbolFolding = <span class="literal">true</span>;</span><br><span class="line">  COMMDirectiveAlignmentIsInBytes = <span class="literal">false</span>;</span><br><span class="line">  HasNoDeadStrip = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">//===--- Dwarf Emission Directives -----------------------------------===//</span></span><br><span class="line">  SupportsDebugInformation = <span class="literal">true</span>;</span><br><span class="line">  UsesCFIWithoutEH = <span class="literal">true</span>;</span><br><span class="line">  DwarfRegNumForCFI = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  UseIntegratedAssembler = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>注册<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">LLVM_EXTERNAL_VISIBILITY <span class="type">void</span> <span class="title">LLVMInitializeAMDGPUTargetMC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="function">RegisterMCAsmInfo&lt;AMDGPUMCAsmInfo&gt; <span class="title">X</span><span class="params">(*T)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>那么inline ptx怎么做呢？其实也可以利用该机制，将ptx视为某个非ptx target所能识别的汇编，但要自定义ptx汇编语句的lexer、parser，并将inlined ptx codegen成llvm ir，所以这就要求将这个特殊的inlined asm处理的pass加在llvm ir阶段。</p><p>由于ptx其实功能非常繁多，直接generate成llvm ir，ir builder的开发量会比较大，并且有一些ptx指令功能其实是比较复杂的，因此我们也可以在llvm ir生成过程中，通过将ptx指令逻辑用c语言实现，放进libdevice库中，而在ir builder时直接生成libdevice function的call inst即可一定程度上提高实现的效率。同样，这也要求我们把pass加在llvm ir阶段，并且在always inliner之前，这样可以让libdevice function call自动inline。</p><blockquote><p>这个实现方案有一个限制，就是编译器不太好区分是inline ptx还是inline native asm，此时需要牺牲掉inline ptx的语法检查功能，将无法解析的inline汇编语法认为是inline native asm，交给下一步inline native asm去处理。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- 
- ～～postencoder～～
- ～～shrink～～
- ～～inline asm/ptx implementation～～
- register definition
  - lanemask length limitation for subregiste</summary>
      
    
    
    
    
    <category term="llvm" scheme="https://chinomars.com/tags/llvm/"/>
    
    <category term="llvm-practice" scheme="https://chinomars.com/tags/llvm-practice/"/>
    
    <category term="compiler" scheme="https://chinomars.com/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>How to support debug on GPU - WIP</title>
    <link href="https://chinomars.com/2025/02/14/how-to-support-debug-on-gpu/"/>
    <id>https://chinomars.com/2025/02/14/how-to-support-debug-on-gpu/</id>
    <published>2025-02-14T13:00:00.000Z</published>
    <updated>2025-04-15T06:05:51.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="How-to-support-debug-on-GPU-WIP"><a href="#How-to-support-debug-on-GPU-WIP" class="headerlink" title="How to support debug on GPU - WIP"></a>How to support debug on GPU - WIP</h1><h2 id="Before-the-Sharing"><a href="#Before-the-Sharing" class="headerlink" title="Before the Sharing"></a>Before the Sharing</h2><p>First time to write a blog in English, worthy to memorize.</p><p>Recently I’m interested by the debugging tech on heterogeneous computing system, CPU with GPU for example, especially the micro-arch design. I’m lucky that I was part of a developper toolchain team, I know a bunch of guys who are really familiar with debugging tech. </p><p>In the beginning of 2018, our team were involved in the first NPU chip project of HUAWEI and we developed logging system(focusing on the software implementation), trace tool, IDE and the prototype of the debugger. Why was just a prototype, which is complicated and no comments here. Anyway, some guys were experts in that team, like my memtor Zheng. We communicated these days and concluded a brief design about the debugging system on GPU&#x2F;NPU system.</p><h2 id="Background-of-Debugging"><a href="#Background-of-Debugging" class="headerlink" title="Background of Debugging"></a>Background of Debugging</h2><p>Basic debug actions include: setting breakpoints, running by step, veiwing variables information(type, address, temporary value). In this blog, I will focus on the hardware support requirements to the “breakpoint setting” and “running by step”.</p><p>In CPU system, OS provides various of system interruptions to support debugging user’s applications. For example INT3 instruction of X86 help trigger a interrupt for the debugger, debugger will catch the signal and process following debugging action, like viewing the value of temporary variable. This is a software level breakpoint. And also there is a hardware way to set a breakpoint. Hardware may design several register for storing breakpoint address, which is the PC address. When polling the breakpoint registers and meeting the PC is equal to the value stored in the breakpoint register, the PC issue module will stop issuing, which implements break action of user’s program.</p><h2 id="GPU-Design-for-supporting-Debugging"><a href="#GPU-Design-for-supporting-Debugging" class="headerlink" title="GPU Design for supporting Debugging"></a>GPU Design for supporting Debugging</h2><p>Both software and hardware ways to set a breakpoint, the hardware should support instruction level interrupt in the micro arch design.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;How-to-support-debug-on-GPU-WIP&quot;&gt;&lt;a href=&quot;#How-to-support-debug-on-GPU-WIP&quot; class=&quot;headerlink&quot; title=&quot;How to support debug on GPU - </summary>
      
    
    
    
    
    <category term="Micro-Arch" scheme="https://chinomars.com/tags/Micro-Arch/"/>
    
    <category term="Debugging" scheme="https://chinomars.com/tags/Debugging/"/>
    
    <category term="Heterogeneous Computing" scheme="https://chinomars.com/tags/Heterogeneous-Computing/"/>
    
  </entry>
  
  <entry>
    <title>一篇不知道多久前翻译的译文--30年之后，QBasic依然是最棒的编程启蒙语言</title>
    <link href="https://chinomars.com/2024/09/13/30-Years-Later-QBasic-Is-Still-The-Best-%E8%AF%91%E6%96%87/"/>
    <id>https://chinomars.com/2024/09/13/30-Years-Later-QBasic-Is-Still-The-Best-%E8%AF%91%E6%96%87/</id>
    <published>2024-09-12T16:18:11.000Z</published>
    <updated>2024-09-12T16:33:30.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="译文：《30年之后，QBasic依然是最棒的编程启蒙语言》"><a href="#译文：《30年之后，QBasic依然是最棒的编程启蒙语言》" class="headerlink" title="译文：《30年之后，QBasic依然是最棒的编程启蒙语言》"></a>译文：《30年之后，QBasic依然是最棒的编程启蒙语言》</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在是北京时间2024年9月13日0点18分，本来是想随便聊聊最近的工作和生活，突然发现drafts目录里有一篇存货，仔细一看原来是不知道什么时候翻译的一篇英文博客。仔细回忆了一下，应该是某个技术自媒体的网友说可以尝试翻译一下投稿，过审了会有稿费。当然，既然是在自己的博客出现，显然是没有过审，看来自己的翻译能力还有待提高，请读者海涵。</p><h2 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h2><p><em>原文链接：<a href="http://www.nicolasbize.com/blog/30-years-later-qbasic-is-still-the-best/">http://www.nicolasbize.com/blog/30-years-later-qbasic-is-still-the-best/</a>   translated by Ti</em></p><p><em>May 5, 2016 by Nicolas Bize</em></p><p>我的大儿子Noah三个月前刚满7岁。在他这个年龄，让他和家人们玩两个小时的《我的世界》也能让他激动得心跳加速。除了《我的世界》之外，他最爱的游戏还有《超级马里奥制造》。看到孩子玩这款游戏也常让我想起自己在这个年龄时的样子，真是令人激动啊。大约5个月之前，我远离家人和朋友去参加一年一度的<a href="http://ludumdare.com/compo/">ludum dare</a><sup>[1]</sup>挑战。和往常一样，我会远离朋友和家人，甚至回到原始的穴居人状态，历时48小时不眠不休地从零开发一款游戏（文章末尾提供了链接，欢迎体验）。当我自豪地向我爱人展示我的“史诗级AAA大作”时，Noah也对编程世界产生了兴趣。于是我向这个不到7岁的孩子简单演示了这些简单的英文单词是如何构建起一个复杂游戏的。从那天起，Noah就开始反复地求我教他如何制作属于他自己的电子游戏。从那天开始，在之后5个月的时间里，我不断地寻找儿童编程语言和IDE的圣杯，渴望着能够将孩子的这种兴趣的火花，变成一段难忘的经历……</p><p>为了达成这个目标，我把目光延伸到了无穷无尽的技术社区。在技术论坛和社区里，技术爱好者们向我提出了不少建议，我也尝试了无数种“儿童编程语言”，例如：SmallBasic，Pico-8，Smalltalk，Scratch等等。我甚至还求助了“万能”的StackOverflow，却都一无所获。5个月之后，我寻找儿童编程语言圣杯的愿望无疾而终，我被迫接受一个非常悲观的事实：30年过去了，QBasic仍然是最适合于编程启蒙的语言，且没有之一。</p><blockquote><p>“天呐，请别教他GOTO！”</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 PRINT “OH NO, WHAT ARE YOU DOING?!!!”</span><br><span class="line">20 GOTO 10</span><br></pre></td></tr></table></figure><p>是的，QBasic确实是一门相当糟糕的过程式编程语言。它将被广泛认为不好的语言特性介绍给所有学习这门语言的人，包括隐式声明语法，不区分大小写，使用non-zero-based<sup>[2]</sup>计数等等。学习编程，最好的做法是从一开始就养成良好的习惯，而非多年之后再来纠正那些不良实践。按照这个逻辑，可能应该从我最爱的Ruby语言开始学习编程。然而，即便QBasic有许多在现在看来不是很恰当的语言特性，但QBasic具备的这些特性，都遵循着一个非常明确的设计目标：保持语言的简单性和易用性，而其他语言常常为了保证灵活性、一定的复杂度和逻辑性抛弃了这两个目标。</p><p>我在Noah的11’’ HP Stream上安装了QBasic，这个过程中还不得不使用了一些DosBox的破解手段。接着Noah双击图标，进入了IDE的介绍界面，这勾起了我很多回忆：</p><p><img src="https://upload.wikimedia.org/wikipedia/en/0/01/QBasic_Opening_Screen.png" alt="img"></p><p>接下来，我向Noah介绍了每一位编程初学者的“神圣的仪式“：开发一个向这个圈子里其他同伴问好的程序。他慢慢地摸索着每一个按键，用右手手指小心翼翼地敲出了一串字符：<code>PRINT &quot;hello world&quot;</code></p><p>他按下了<em>F5</em>键，当他看到自己的代码被编译、渲染到一片漆黑的屏幕上时，Noah显得非常惊喜。他欢笑着给了他老爹一个high-five，然后赶紧把电脑中刚刚敲下的代码抄录到了自己的笔记本上，为了防止自己忘记。</p><p><img src="http://nicolasbize.com/blog/images/noah_1.jpg" alt="img"></p><p>我们继续学习了其他指令：<code>CLS, COLOR, PLAY, INPUT</code>和<code>IF</code>。全程无需任何多余的解释，没有任何复杂度，没有生涩的操作符，没有抽象概念，没有必须仔细阅读的文档和手册，没有<em>object&#x2F;class&#x2F;method</em>等高级概念，不用安装任何开发框架，IDE中也没有大片的菜单和按钮，也没有特殊的单词和括号。一切仅仅是格式简单的纯代码。</p><p>不到1个小时，Noah就独立地写出了一个程序——一个交互式的，非常微妙的小程序，这个程序让你明白了计算机对你作为一个有情感的人类个体的感受。</p><p><img src="http://nicolasbize.com/blog/images/noah_3.jpg" alt="img"></p><p>随后他立马邀请来他最好的朋友Christian，并把程序运行给他看，极其自豪。</p><p><img src="http://nicolasbize.com/blog/images/noah_4.jpg" alt="img"></p><p>Noah甚至还给好朋友简单地介绍了这个程序的是如何运行的，以及这些代码的含义！</p><p><img src="http://nicolasbize.com/blog/images/noah_5.jpg" alt="img"></p><p>在这一个小时中，我这年龄才7岁的儿子不仅学会了写第一个纯文本交互游戏，还体验了创造的乐趣和激动，编译并运行了他那个小程序。更值得表演的是，他还将全部的学习成果记录在了笔记本上，这个习惯非常不错：</p><p><img src="http://nicolasbize.com/blog/images/noah_2.jpg" alt="img"></p><p>我很开心的是，今天Noah终于体会到了他爸爸一直在说的“我做着全世界最棒的工作”。而我唯一感到遗憾的是认识到了一个悲观的现实，经过了30多年，我们仍然没有创造出对于儿童编程更适合的编程语言：QBasic只有非常有限的关键字（全部的帮助文档只需一个<em>F1</em>屏，并且还能附上简单的示例），没有任何让程序员分心的可视化组件，具有非常紧凑的开发环境，它能尽可能早地报错，使用简单的一键式编译和运行。这么多年来，我们创造出了更稳定、更复杂的语言&#x2F;框架&#x2F;IDE。诚然，对于现实真正的应用开发而言，足够的稳定性和复杂度是必须的，但我们还是没能创造出比QBasic更简单、更容易让初学者感受到编程的快乐的语言。而且在“现代化”的软件生态和环境中，让新手用现代计算机（Mac&#x2F;PC&#x2F;Linux）去运行QBasic也变得让人感到恐惧，放在当年，只需要将一个3.5英寸的磁盘插入硬盘驱动即可······</p><p>不论如何，今天值得庆祝的是，又有一位新朋友发现了编程的快乐与美丽！欢呼～</p><p>（按照文章开头的约定，欢迎体验<a href="http://nicolasbize.com/ld34/">我的AAA大作</a>，而我，就等着EA来向我够买版权了）</p><p>译者注：</p><p>[1] Ludam Dare：Ludam Dare是一个世界级的在线、快速游戏开发挑战活动。要求参与者利用一个周末的时间，基于赛前社区票选出的主题，从零开始制作一款游戏。</p><p>[2] Non-zero-based：Zero-based是一种从0开始的计数方法，相反Non-zero-based计数法是从非零数开始计数，例如从1开始。严格来讲从0开始或从1开始计数并没有对和错之分，但在计算机领域尤其是在编程语言领域，从0开始计数是一个比较常见的惯例，大部分具有一定影响力的编程语言也是这么设计的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;译文：《30年之后，QBasic依然是最棒的编程启蒙语言》&quot;&gt;&lt;a href=&quot;#译文：《30年之后，QBasic依然是最棒的编程启蒙语言》&quot; class=&quot;headerlink&quot; title=&quot;译文：《30年之后，QBasic依然是最棒的编程启蒙语言》&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="Programming Language" scheme="https://chinomars.com/tags/Programming-Language/"/>
    
    <category term="Misc" scheme="https://chinomars.com/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>LLVM Note - Instruction Selection In LLVM</title>
    <link href="https://chinomars.com/2022/03/17/ISel/"/>
    <id>https://chinomars.com/2022/03/17/ISel/</id>
    <published>2022-03-16T16:18:11.000Z</published>
    <updated>2025-03-18T15:20:40.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Instruction-Selection-In-LLVM"><a href="#Instruction-Selection-In-LLVM" class="headerlink" title="Instruction Selection In LLVM"></a>Instruction Selection In LLVM</h1><h2 id="Instruction-Selection-Method"><a href="#Instruction-Selection-Method" class="headerlink" title="Instruction Selection Method"></a>Instruction Selection Method</h2><ul><li>FastISel</li><li>SelectionDAGISel</li><li>GlobalISel</li></ul><p>related hooks, like how to specify which isel method to use</p><ul><li>in <code>TargetConfig::addCoreISelPasses</code> will choose a valid isel method</li></ul><h3 id="FastISel"><a href="#FastISel" class="headerlink" title="FastISel"></a>FastISel</h3><ul><li>llvm ir based</li><li>fast</li><li>used in O0</li></ul><h4 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h4><p>llvm ir -&gt; machine instruction with virtual register</p><h4 id="how-to-impl"><a href="#how-to-impl" class="headerlink" title="how to impl"></a>how to impl</h4><ol><li>define a class inherit from <code>FastISel</code></li><li>override a virtual function <code>fastSelectInstruction</code>, then emit each opcode in llvm ir which is target dependent</li></ol><h3 id="SelectionDAG-based-ISel"><a href="#SelectionDAG-based-ISel" class="headerlink" title="SelectionDAG based ISel"></a>SelectionDAG based ISel</h3><ul><li>should lowering to DAG first from llvm ir</li><li>will do several times legalize and combine in instruction selecting, includes:<ul><li>type legalize then combine</li><li>vector legalize then combine</li><li>dag legalize then combine</li></ul></li><li>will do heuristic schdeule on DAG after selected to MachineDAG</li></ul><h4 id="workflow-1"><a href="#workflow-1" class="headerlink" title="workflow"></a>workflow</h4><p>llvm ir -&gt; lowering to DAG -&gt; initialize DAG -&gt; combine -&gt; type legalize and combine -&gt; vector legalize and type legalize and combine -&gt; dag legalize and combine -&gt; insturction selection -&gt; instruction scheduling(will introduce later)</p><h4 id="how-to-impl-1"><a href="#how-to-impl-1" class="headerlink" title="how to impl"></a>how to impl</h4><ol><li>define a class inherit from <code>SelectionDAGISel</code></li><li>override the entry of selection isel <code>Select()</code></li><li>override most of all <code>selectXXX</code> virtual function to select instruction, usually named as <code>&lt;TargetName&gt;DAGToDAGISel()</code></li></ol><h4 id="what-is-lowering"><a href="#what-is-lowering" class="headerlink" title="what is lowering"></a>what is lowering</h4><p>lowering define some legalization info and other rules for DAG builder when SelectionDAG is initialized</p><h3 id="GlobalISel"><a href="#GlobalISel" class="headerlink" title="GlobalISel"></a>GlobalISel</h3><p>TODO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Instruction-Selection-In-LLVM&quot;&gt;&lt;a href=&quot;#Instruction-Selection-In-LLVM&quot; class=&quot;headerlink&quot; title=&quot;Instruction Selection In LLVM&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="Compiler" scheme="https://chinomars.com/tags/Compiler/"/>
    
    <category term="LLVM" scheme="https://chinomars.com/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>REPL技术分析——Python的交互式</title>
    <link href="https://chinomars.com/2020/02/12/Python%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F/"/>
    <id>https://chinomars.com/2020/02/12/Python%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F/</id>
    <published>2020-02-11T16:20:11.000Z</published>
    <updated>2024-09-12T15:47:28.060Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>Python是一种解释型语言，通过解释器对代码进行逐行执行，一般的解释器也是这样实现，当然也存在一些优化方法，对代码进行JIT编译，提高执行速度。所以Python的REPL可以说是原生支持的。</p><p>Python语言有多种解释器，例如：</p><ul><li>CPython：C语言实现的Python解释器，一般情况下在Terminal中执行命令<code>python</code>，就会调用CPython解释器执行代码</li><li>PyPy：前面提到的通过JIT技术提升Python代码执行速度</li><li>IPython：Python的交互式解释器，底层也是通过调用CPython对代码进行解释执行</li></ul><p>回到主题REPL，我们可以以IPython为入口进行分析，进一步对CPython进行分析</p><h3 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h3><p>个人习惯，从源码出发分析。IPtyhon的github源码仓，<a href="https://github.com/ipython/ipython">链接</a>，交互式开发的mainloop的代码在这个interactiveshell.py中，我们可以看到，IPython支持一个完整的代码块的交互式运行，采用异步的方式运行以保证一定的用户体验。一个完整的代码块，由用户输入，可以是一行完整的python代码，也可以是多行语法的代码块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_run_cell</span>(<span class="params">self, raw_cell:<span class="built_in">str</span>, store_history:<span class="built_in">bool</span>, silent:<span class="built_in">bool</span>, shell_futures:<span class="built_in">bool</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Internal method to run a complete IPython cell.&quot;&quot;&quot;</span></span><br><span class="line">        coro = <span class="variable language_">self</span>.run_cell_async(</span><br><span class="line">            raw_cell,</span><br><span class="line">            store_history=store_history,</span><br><span class="line">            silent=silent,</span><br><span class="line">            shell_futures=shell_futures,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># run_cell_async is async, but may not actually need an eventloop.</span></span><br><span class="line">        <span class="comment"># when this is the case, we want to run it using the pseudo_sync_runner</span></span><br><span class="line">        <span class="comment"># so that code can invoke eventloops (for example via the %run , and</span></span><br><span class="line">        <span class="comment"># `%paste` magic.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.trio_runner:</span><br><span class="line">            runner = <span class="variable language_">self</span>.trio_runner</span><br><span class="line">        <span class="keyword">elif</span> <span class="variable language_">self</span>.should_run_async(raw_cell):</span><br><span class="line">            runner = <span class="variable language_">self</span>.loop_runner</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            runner = _pseudo_sync_runner</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> runner(coro)</span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">            info = ExecutionInfo(raw_cell, store_history, silent, shell_futures)</span><br><span class="line">            result = ExecutionResult(info)</span><br><span class="line">            result.error_in_exec = e</span><br><span class="line">            <span class="variable language_">self</span>.showtraceback(running_compiled_code=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>继续分析这个run_cell_async：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">run_cell_async</span>(<span class="params">self, raw_cell: <span class="built_in">str</span>, store_history=<span class="literal">False</span>, silent=<span class="literal">False</span>, shell_futures=<span class="literal">True</span></span>) -&gt; ExecutionResult:</span><br><span class="line">        info = ExecutionInfo(</span><br><span class="line">            raw_cell, store_history, silent, shell_futures)</span><br><span class="line">        result = ExecutionResult(info)</span><br><span class="line">...</span><br><span class="line">        <span class="comment"># If any of our input transformation (input_transformer_manager or</span></span><br><span class="line">        <span class="comment"># prefilter_manager) raises an exception, we store it in this variable</span></span><br><span class="line">        <span class="comment"># so that we can display the error after logging the input and storing</span></span><br><span class="line">        <span class="comment"># it in the history.</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cell = <span class="variable language_">self</span>.transform_cell(raw_cell)</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Store raw and processed history</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Display the exception if input processing failed.</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Our own compiler remembers the __future__ environment. If we want to</span></span><br><span class="line">        <span class="comment"># run code with a separate __future__ environment, use the default</span></span><br><span class="line">        <span class="comment"># compiler</span></span><br><span class="line">        compiler = <span class="variable language_">self</span>.<span class="built_in">compile</span> <span class="keyword">if</span> shell_futures <span class="keyword">else</span> CachingCompiler()</span><br><span class="line">        _run_async = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">with</span> <span class="variable language_">self</span>.builtin_trap:</span><br><span class="line">            cell_name = <span class="variable language_">self</span>.<span class="built_in">compile</span>.cache(cell, <span class="variable language_">self</span>.execution_count)</span><br><span class="line">            <span class="keyword">with</span> <span class="variable language_">self</span>.display_trap:</span><br><span class="line">                <span class="comment"># Compile to bytecode</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">if</span> sys.version_info &lt; (<span class="number">3</span>,<span class="number">8</span>) <span class="keyword">and</span> <span class="variable language_">self</span>.autoawait:</span><br><span class="line">                        <span class="keyword">if</span> _should_be_async(cell):</span><br><span class="line">                            <span class="comment"># the code AST below will not be user code: we wrap it</span></span><br><span class="line">                            <span class="comment"># in an `async def`. This will likely make some AST</span></span><br><span class="line">                            <span class="comment"># transformer below miss some transform opportunity and</span></span><br><span class="line">                            <span class="comment"># introduce a small coupling to run_code (in which we</span></span><br><span class="line">                            <span class="comment"># bake some assumptions of what _ast_asyncify returns.</span></span><br><span class="line">                            <span class="comment"># they are ways around (like grafting part of the ast</span></span><br><span class="line">                            <span class="comment"># later:</span></span><br><span class="line">                            <span class="comment">#    - Here, return code_ast.body[0].body[1:-1], as well</span></span><br><span class="line">                            <span class="comment">#    as last expression in  return statement which is</span></span><br><span class="line">                            <span class="comment">#    the user code part.</span></span><br><span class="line">                            <span class="comment">#    - Let it go through the AST transformers, and graft</span></span><br><span class="line">                            <span class="comment">#    - it back after the AST transform</span></span><br><span class="line">                            <span class="comment"># But that seem unreasonable, at least while we</span></span><br><span class="line">                            <span class="comment"># do not need it.</span></span><br><span class="line">                            code_ast = _ast_asyncify(cell, <span class="string">&#x27;async-def-wrapper&#x27;</span>)</span><br><span class="line">                            _run_async = <span class="literal">True</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            code_ast = compiler.ast_parse(cell, filename=cell_name)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        code_ast = compiler.ast_parse(cell, filename=cell_name)</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment"># Apply AST transformations</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    code_ast = <span class="variable language_">self</span>.transform_ast(code_ast)</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment"># Execute the user code</span></span><br><span class="line">                interactivity = <span class="string">&quot;none&quot;</span> <span class="keyword">if</span> silent <span class="keyword">else</span> <span class="variable language_">self</span>.ast_node_interactivity</span><br><span class="line">                <span class="keyword">if</span> _run_async:</span><br><span class="line">                    interactivity = <span class="string">&#x27;async&#x27;</span></span><br><span class="line"></span><br><span class="line">                has_raised = <span class="keyword">await</span> <span class="variable language_">self</span>.run_ast_nodes(code_ast.body, cell_name,</span><br><span class="line">                       interactivity=interactivity, compiler=compiler, result=result)</span><br><span class="line">...</span><br><span class="line">                <span class="comment"># Reset this so later displayed values do not modify the</span></span><br><span class="line">                <span class="comment"># ExecutionResult</span></span><br><span class="line">                <span class="variable language_">self</span>.displayhook.exec_result = <span class="literal">None</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>我把一些异常处理的代码省略了，不关键的跳过。删除不关键的处理流程后我们可以分析下源码：</p><ul><li>首先是将cell代码块（raw_cell），执行历史（store_history），以及一些设置运行模式的参数（silent和shell_futures）来示例化成ExecutionInfo，然后将它塞到ExecutionResult这个方法中，做进一步的封装，方便后续进行执行过程中关键信息的存储</li><li><code>tramsform_cell</code>的工作主要是做一些行的分割以及其他处理，例如确保每一个输入cell最后有一个空行，这个也是编译器的常规操作，方便parsing的时候计算报错行号</li><li><code>_ast_asyncify</code>是一个异步方法，将输入cell（源码）解析为ast，同样其他两个分支都是将输入解析为ast，这里的分支是为了区分版本，解决版本兼容性。这里的<code>compiler</code>我们没有在IPython源码中找到定义，推测是CPython的封装，后续再分析</li><li><code>run_ast_nodes</code>也是调用了compiler的能力，下面我们就可以去CPython中进一步分析了</li></ul><p>IPython主要对CPython进行封装，将ast导入给CPython进行执行。并且，部分情况下并没有调用compiler封装的run_code方法，而是直接使用Python内置的exec()方法执行python代码，处理也比较简单。</p><h3 id="CPython"><a href="#CPython" class="headerlink" title="CPython"></a>CPython</h3><p>CPython是python解释器的c语言实现，也是Python的官方解释器。按照惯例我们还是从源码入手，cpython托管在github上，<a href="https://github.com/python/cpython">项目链接</a>。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>首先从main函数出发，找到<code>Programs/python.c</code>中的main函数，在进入到repl loop之前，我们快速过一下执行流程。当然，对于c&#x2F;c++项目而言，最万能的方式还是通过调试，一步一步地借助断点和查看调用栈来分析。在只关注一个具体的功能的时候，个人还是比较偏向于直接看源码，聚焦关键的函数。</p><p>执行流程：</p><ul><li><code>Programs/python.c:16 =&gt; Py_BytesMain</code></li><li><code>Modules/main.c:679 =&gt; pymain_main</code></li><li><code>Modules/main.c:627 Py_RunMain =&gt; pymain_run_python</code></li></ul><p>到pymain_run_python()函数，我们可以具体看一下这个函数里的构成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">pymain_run_python</span><span class="params">(<span class="type">int</span> *exitcode)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (config-&gt;run_command) &#123;</span><br><span class="line">        *exitcode = pymain_run_command(config-&gt;run_command, &amp;cf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (config-&gt;run_module) &#123;</span><br><span class="line">        *exitcode = pymain_run_module(config-&gt;run_module, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (main_importer_path != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *exitcode = pymain_run_module(<span class="string">L&quot;__main__&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (config-&gt;run_filename != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *exitcode = pymain_run_file(config, &amp;cf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        *exitcode = pymain_run_stdin(config, &amp;cf);</span><br><span class="line">    &#125;</span><br><span class="line">    pymain_repl(config, &amp;cf, exitcode);</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，通过函数最开始构建的运行环境配置（config），来决定后续的分支：</p><ul><li>run_command分支：调用<code>pymain_run_command()</code>函数，来执行命令</li><li>run_module分支：调用<code>pymain_run_module()</code>函数，运行一个python模块</li><li>run_filename分支：调用<code>pymain_run_file()</code>函数，运行一个python文件</li><li>其他：调用<code>pymain_run_stdin()</code>函数，来执行一个标准输入</li><li>最后：调用<code>pymain_repl()</code>函数，启动repl</li></ul><p>上述执行分支中，估计大家对于最后两个分支（<strong>其他</strong>和<strong>最后</strong>）会感到十分疑惑，看起来逻辑有重复，<strong>其他</strong>分支中，调用<code>pymain_run_stdin()</code>函数后，再启动repl。实际上最后两个分支最终调用的函数都是一样的：</p><ul><li><code>pymain_run_stdin()</code>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">pymain_run_stdin</span><span class="params">(PyConfig *config, PyCompilerFlags *cf)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="type">int</span> run = PyRun_AnyFileExFlags(<span class="built_in">stdin</span>, <span class="string">&quot;&lt;stdin&gt;&quot;</span>, <span class="number">0</span>, cf);</span><br><span class="line">    <span class="keyword">return</span> (run != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>pymain_repl()</code>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">pymain_repl</span><span class="params">(PyConfig *config, PyCompilerFlags *cf, <span class="type">int</span> *exitcode)</span></span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="type">int</span> res = PyRun_AnyFileFlags(<span class="built_in">stdin</span>, <span class="string">&quot;&lt;stdin&gt;&quot;</span>, cf);</span><br><span class="line">    *exitcode = (res != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，在<code>pymain_repl()</code>中调用的<code>PyRun_AnyFileFlags()</code>，在<code>include/pythonrun.h</code>中定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyRun_AnyFileFlags(fp, name, flags) \</span></span><br><span class="line"><span class="meta">    PyRun_AnyFileExFlags(fp, name, 0, flags)</span></span><br></pre></td></tr></table></figure><p>是一毛一样的呢。最终就执行到了我们的重头戏：<code>Python/pythonrun.c:91 PyRun_InteractiveLoopFlags()</code></p><h4 id="interactive-loop"><a href="#interactive-loop" class="headerlink" title="interactive loop"></a>interactive loop</h4><p><code>PyRun_InteractiveLoopFlags(stdin, &quot;&lt;stdin&gt;&quot;, 0, cf)</code>中，从<code>stdin</code>标准输入流中读取用户输入，进行执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyRun_InteractiveLoopFlags</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename_str, PyCompilerFlags *flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ret = PyRun_InteractiveOneObjectEx(fp, filename, flags);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; PyErr_Occurred()) &#123;</span><br><span class="line">...</span><br><span class="line">            PyErr_Print();</span><br><span class="line">            flush_io();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nomem_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (ret != E_EOF);</span><br><span class="line">    Py_DECREF(filename);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>PyRun_InteractiveOneObjectEx()</code>函数执行用户输入。</p><p>我们可以看到对于一个Python Object的执行流程如下：</p><ul><li><code>_PyUnicode_FromId</code>：造一个modulename</li><li><code>_PySys_GetObjectId</code>：从stdin中读取用户输入</li><li><code>PyImport_AddModuleObject</code>：加载import模块</li><li><code>run_mod</code>：运行module</li></ul><p><code>run_mod()</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">run_mod</span><span class="params">(mod_ty mod, PyObject *filename, PyObject *globals, PyObject *locals,</span></span><br><span class="line"><span class="params">            PyCompilerFlags *flags, PyArena *arena)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyCodeObject *co;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    co = PyAST_CompileObject(mod, filename, flags, <span class="number">-1</span>, arena);</span><br><span class="line">    <span class="keyword">if</span> (co == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PySys_Audit(<span class="string">&quot;exec&quot;</span>, <span class="string">&quot;O&quot;</span>, co) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Py_DECREF(co);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v = run_eval_code_obj(co, globals, locals);</span><br><span class="line">    Py_DECREF(co);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先将python moduleParse成AST（调用<code>PyAST_CompileObject()</code>函数），再编译成Python的ByteCode，最后塞给<code>run_eval_code_obj()</code>函数进行执行。</p><p>基本上repl的执行流程就讲完了，有点困了，有（bu）时（xiang）间（nong）再细化补充，欢迎留言。</p><p>源码分析地比较粗糙，找到一片详细debug，介绍cpython中的编译执行流程的博客，见最后一片参考文章（Internals of CPython），写得比较详细，甚至还简单介绍了gdb的使用方式，很贴心。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.liaoxuefeng.com/wiki/897692888725344/966138843228672">Python解释器</a></p><p><a href="https://github.com/ipython/ipython/blob/master/IPython/core/interactiveshell.py">interactiveshell.py</a></p><p><a href="https://github.com/python/cpython/blob/master/Modules/main.c">Modules&#x2F;main.c</a></p><p><a href="https://github.com/python/cpython/blob/master/Python/pythonrun.c">Python&#x2F;pythonrun.c</a></p><p><a href="https://hackmd.io/@xff9N3eQTLSL4Trq-6setg/ByMHBMjFe?type=view">Internals of CPython</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h3&gt;&lt;p&gt;Python是一种解释型语言，通过解释器对代码进行逐行执行，一般的解释器也是这样实现，当然也存在一些优化方法，对代码进行JIT编译，提高执行</summary>
      
    
    
    
    
    <category term="Compiler" scheme="https://chinomars.com/tags/Compiler/"/>
    
    <category term="Python" scheme="https://chinomars.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>REPL技术分析——Swift REPL模式</title>
    <link href="https://chinomars.com/2020/02/07/Swift-REPL%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/"/>
    <id>https://chinomars.com/2020/02/07/Swift-REPL%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-02-07T08:45:43.000Z</published>
    <updated>2024-09-12T15:47:28.060Z</updated>
    
    <content type="html"><![CDATA[<h3 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h3><p>在IR层面支持REPL，提供swift解释器，swift提供了编译器runtime，提供基础的词法分析、语法分析、IR生成能力，并可基于llvm ir进行表达式eval，通过JIT的方式在解释器中支持REPL。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ol><li><p>头文件：<code>include/swift/Immediate/Immediate.h</code>，包含两个接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RunImmediately</span><span class="params">(CompilerInstance &amp;CI, <span class="type">const</span> ProcessCmdLine &amp;CmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> IRGenOptions &amp;IRGenOpts, <span class="type">const</span> SILOptions &amp;SILOpts,</span></span></span><br><span class="line"><span class="params"><span class="function">                     std::unique_ptr&lt;SILModule&gt; &amp;&amp;SM)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">runREPL</span><span class="params">(CompilerInstance &amp;CI, <span class="type">const</span> ProcessCmdLine &amp;CmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">bool</span> ParseStdlib)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>RunImmediately方法用于基于<strong>SIL（Swift Intermediate Language）</strong>，立即Eval当前IR Module，相当于是解释器</li><li>runREPL方法提供给FrontendTool.cpp前端逻辑进行调用，作为REPL的main loop</li></ul></li><li><p>源码文件：Immediate.cpp</p></li></ol><p>实现几个功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">loadSwiftRuntime</span><span class="params">(ArrayRef&lt;std::string&gt; runtimeLibPaths)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">tryLoadLibraries</span><span class="params">(ArrayRef&lt;LinkLibrary&gt; LinkLibraries,</span></span></span><br><span class="line"><span class="params"><span class="function">                      SearchPathOptions SearchPathOpts,</span></span></span><br><span class="line"><span class="params"><span class="function">                      DiagnosticEngine &amp;Diags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">linkLLVMModules</span><span class="params">(llvm::Module *Module,</span></span></span><br><span class="line"><span class="params"><span class="function">                     std::unique_ptr&lt;llvm::Module&gt; SubModule)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">autolinkImportedModules</span><span class="params">(ModuleDecl *M, <span class="type">const</span> IRGenOptions &amp;IRGenOpts)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">swift::RunImmediately</span><span class="params">(CompilerInstance &amp;CI,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> ProcessCmdLine &amp;CmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> IRGenOptions &amp;IRGenOpts,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> SILOptions &amp;SILOpts,</span></span></span><br><span class="line"><span class="params"><span class="function">                          std::unique_ptr&lt;SILModule&gt; &amp;&amp;SM)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>加载swift编译器runtime：swiftCore</li><li>llvm ir module间合并</li><li>import module的支持</li><li>RunImmediately：将input翻译成llvm ir，调用<code>llvm::ExecutionEngine</code>直接执行llvm ir</li></ul><ol start="3"><li>源码文件：REPL.cpp</li></ol><p>REPL的主函数，从Frontend.cpp进来，主要由一个读取用户input的main loop，对每个输入进行处理。依赖histedit的支持</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p><a href="https://blog.csdn.net/weixin_43740680/article/details/98234795">What’s REPL</a></p><p><a href="https://github.com/apple/swift/blob/master/lib/Immediate/Immediate.cpp">Source Code Immediate.cpp</a></p><p><a href="https://github.com/apple/swift/blob/master/lib/Immediate/REPL.cpp">Source Code REPL.cpp</a></p><p><a href="http://ftp.netbsd.org/pub/NetBSD/NetBSD-current/src/lib/libedit/histedit.h">histedit.h: Line editor and history interface.</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;技术路线&quot;&gt;&lt;a href=&quot;#技术路线&quot; class=&quot;headerlink&quot; title=&quot;技术路线&quot;&gt;&lt;/a&gt;技术路线&lt;/h3&gt;&lt;p&gt;在IR层面支持REPL，提供swift解释器，swift提供了编译器runtime，提供基础的词法分析、语法分析、IR生成能</summary>
      
    
    
    
    
    <category term="Compiler" scheme="https://chinomars.com/tags/Compiler/"/>
    
    <category term="Swift" scheme="https://chinomars.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>基于Hexo和github page搭建个人博客</title>
    <link href="https://chinomars.com/2020/01/29/%E5%9F%BA%E4%BA%8EHexo%E5%92%8Cgithub-page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://chinomars.com/2020/01/29/%E5%9F%BA%E4%BA%8EHexo%E5%92%8Cgithub-page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-01-29T11:46:47.000Z</published>
    <updated>2024-09-12T15:47:28.060Z</updated>
    
    <content type="html"><![CDATA[<p>倒腾过好几次个人主页，但个人原创文章并不多，总是要么在换模板的路上，要不就是在换框架的路上，终于乐此而疲了。这次换个人主页之后还是要静下心来多写文章才是。这篇文章用于答谢Hexo和Archer主题的作者，hexo是到目前为止用过的最好用的博客框架，archer主题模板是目前个人比较喜欢的一款模版。</p><p>废话不多说，按照个人习惯，分四段简单介绍下如何基于Hexo和Github Page搭建个人主页。</p><blockquote><p>本文不严格区分*nix系统和windows系统，所有命令均可在terminal或者gitbash中执行。</p></blockquote><h2 id="0x00-准备"><a href="#0x00-准备" class="headerlink" title="0x00 准备"></a>0x00 准备</h2><p>hexo是一个静态站点生成工具，集创建（初始化站点）、开发（指的是写博客）、发布博客文章功能于一体，十分方便。</p><p>搭建博客站点先准备以下平台的账号和开发环境：</p><ul><li><p>注册github账户，<a href="https://github.com/">链接</a></p></li><li><p>安装git，并在github账户中配置sshkey：*nix系统一般自带git，windows系统安装gitbash，<a href="https://gitforwindows.org/">下载地址</a></p></li><li><p>配置sshkey：</p><ul><li><p>生成sshkey：*nix系统中打开terminal，windows系统中打开gitbash，参考<a href="https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh">教程</a>，执行以下命令，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~ &amp;&amp; ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span> <span class="comment"># your_email@example.com替换为你注册github的邮箱，可以一直按回车生成默认的文件名，方便阅读后续的步骤</span></span><br></pre></td></tr></table></figure></li><li><p>执行以下命令，拷贝出你的public key，将屏幕中输出的公钥内容<code>ctrl+c</code>进行拷贝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh/ &amp;&amp; <span class="built_in">cat</span> id_rsa.pub <span class="comment"># 这里的id_rsa.pub为上一步生成的密钥对中的公钥</span></span><br></pre></td></tr></table></figure></li><li><p>打开github中配置sshkey的界面，<a href="https://github.com/settings/keys">链接</a>，选择<code>New SSH key</code>，把拷贝的公钥配置上去即可。</p></li></ul></li><li><p>安装Nodejs，<a href="https://nodejs.org/zh-cn/">下载地址</a>，安装成功后会同时安装好node和npm两个工具，并为npm配置国内源，例如配置淘宝源可以执行下述命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li><p>安装hexo，执行下述命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g <span class="comment"># install hexo</span></span><br><span class="line">hexo -v <span class="comment"># check whether successfully installed</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="0x01-初始化站点"><a href="#0x01-初始化站点" class="headerlink" title="0x01 初始化站点"></a>0x01 初始化站点</h2><p>执行以下命令来初始化博客站点，会创建一个新的目录，以blog-dev为例，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog-dev</span><br></pre></td></tr></table></figure><p>待命令执行完毕，会新建一个blog-dev目录，进入该目录中，我们可以看到以下目录树：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">blog-dev</span><br><span class="line">├── _config.yml        <span class="comment">#---------------- 站点配置文件</span></span><br><span class="line">├── node_modules       <span class="comment">#---------------- npm安装包本地保存目录</span></span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json       <span class="comment">#---------------- 依赖包配置文件</span></span><br><span class="line">├── scaffolds</span><br><span class="line">├── <span class="built_in">source</span>             <span class="comment">#---------------- 博客文章保存目录</span></span><br><span class="line">└── themes             <span class="comment">#---------------- 博客主题保存目录</span></span><br></pre></td></tr></table></figure><p>此时，进入到blog-dev目录，可以执行hexo的相关参数及命令，可以进行站点的管理，简单介绍如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment"># 清除缓存</span></span><br><span class="line">hexo generate <span class="comment"># 生成网站静态文件</span></span><br><span class="line">hexo server <span class="comment"># 启动本地调试模式，默认可以打开localhost:4000查看网站效果</span></span><br><span class="line">hexo deploy <span class="comment"># 发布到GitHub Page，第0x11节会具体介绍</span></span><br></pre></td></tr></table></figure><p>hexo还有一个非常方便的点是主题套用十分方便，将想要的模板下载下来，放到themes目录下，然后修改_config.yml文件中的theme字段，改为下载下来的主题目录名即可。主题可以在<a href="https://hexo.io/themes/">官方网站下载</a>，也可以自行从各种渠道获取。</p><h2 id="0x10-创建github-page"><a href="#0x10-创建github-page" class="headerlink" title="0x10 创建github page"></a>0x10 创建github page</h2><p>本节内容大家应该都比较熟悉，创建作为个人主页用的github page，必须将仓名命名为username.github.com，经过测试，仓名中的username与你的github账号名可以不区分大小写。</p><p>这部分教程我想偷懒跳过了，可以自行查看<a href="https://pages.github.com/">官方教程</a>。</p><h2 id="0x11-预览和发布"><a href="#0x11-预览和发布" class="headerlink" title="0x11 预览和发布"></a>0x11 预览和发布</h2><p>在blog-dev目录下执行<code>hexo new &#39;博客标题&#39;</code>即可创建一篇新的博客，使用markdown语法进行编辑。</p><p>编辑完毕之后，执行下述命令，可以启动一个本地的临时服务器进行预览：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server <span class="comment"># 启动本地预览服务</span></span><br></pre></td></tr></table></figure><p>在浏览器中打开<code>localhost:4000</code>，即可预览你的博客。</p><p>配置blog-dev的发布路径，编辑blog-dev&#x2F;_config.yml文件，一般在文件末尾，有一个deploy字段，把第三节创建的github page仓库路径配置上去即可，如果deploy字段下只有一个type，则手动添加其他字段（注意yml文件遵从yaml格式缩紧）。例如我的配置就是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span>                                                                                                          </span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/ChinoMars/chinomars.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>依次执行下述命令，即可发布你的静态站点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment"># 清除缓存</span></span><br><span class="line">hexo generate <span class="comment"># 生成站点的静态文件</span></span><br><span class="line">hexo deploy <span class="comment"># 自动push到github page所在的master分支，进行发布</span></span><br></pre></td></tr></table></figure><p>最后，可以打开网址：<code>https://username.github.io</code>即可查看个人的站点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;倒腾过好几次个人主页，但个人原创文章并不多，总是要么在换模板的路上，要不就是在换框架的路上，终于乐此而疲了。这次换个人主页之后还是要静下心来多写文章才是。这篇文章用于答谢Hexo和Archer主题的作者，hexo是到目前为止用过的最好用的博客框架，archer主题模板是目前</summary>
      
    
    
    
    
    <category term="小白" scheme="https://chinomars.com/tags/%E5%B0%8F%E7%99%BD/"/>
    
  </entry>
  
</feed>
