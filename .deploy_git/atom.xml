<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chino&#39;s Studio</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chinomars.com/"/>
  <updated>2020-12-13T18:04:56.565Z</updated>
  <id>https://chinomars.com/</id>
  
  <author>
    <name>Chino Mars</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>30-Years-Later-QBasic-Is-Still-The-Best-译文</title>
    <link href="https://chinomars.com/2020/12/02/30-Years-Later-QBasic-Is-Still-The-Best-%E8%AF%91%E6%96%87/"/>
    <id>https://chinomars.com/2020/12/02/30-Years-Later-QBasic-Is-Still-The-Best-%E8%AF%91%E6%96%87/</id>
    <published>2020-12-02T15:16:51.607Z</published>
    <updated>2020-12-13T18:04:56.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="30年之后，QBasic依然是最棒的编程启蒙语言"><a href="#30年之后，QBasic依然是最棒的编程启蒙语言" class="headerlink" title="30年之后，QBasic依然是最棒的编程启蒙语言"></a>30年之后，QBasic依然是最棒的编程启蒙语言</h1><p><em>原文链接：<a href="http://www.nicolasbize.com/blog/30-years-later-qbasic-is-still-the-best/" target="_blank" rel="noopener">http://www.nicolasbize.com/blog/30-years-later-qbasic-is-still-the-best/</a>   translated by Ti</em></p><p><em>May 5, 2016 by Nicolas Bize</em></p><p>我的大儿子Noah三个月前刚满7岁。在他这个年龄，让他和家人们玩两个小时的《我的世界》也能让他激动得心跳加速。除了《我的世界》之外，他最爱的游戏还有《超级马里奥制造》。看到孩子玩这款游戏也常让我想起自己在这个年龄时的样子，真是令人激动啊。大约5个月之前，我远离家人和朋友去参加一年一度的<a href="http://ludumdare.com/compo/" target="_blank" rel="noopener">ludum dare</a><sup>[1]</sup>挑战。和往常一样，我会远离朋友和家人，甚至回到原始的穴居人状态，历时48小时不眠不休地从零开发一款游戏（文章末尾提供了链接，欢迎体验）。当我自豪地向我爱人展示我的“史诗级AAA大作”时，Noah也对编程世界产生了兴趣。于是我向这个不到7岁的孩子简单演示了这些简单的英文单词是如何构建起一个复杂游戏的。从那天起，Noah就开始反复地求我教他如何制作属于他自己的电子游戏。从那天开始，在之后5个月的时间里，我不断地寻找儿童编程语言和IDE的圣杯，渴望着能够将孩子的这种兴趣的火花，变成一段难忘的经历……</p><p>为了达成这个目标，我把目光延伸到了无穷无尽的技术社区。在技术论坛和社区里，技术爱好者们向我提出了不少建议，我也尝试了无数种“儿童编程语言”，例如：SmallBasic，Pico-8，Smalltalk，Scratch等等。我甚至还求助了“万能”的StackOverflow，却都一无所获。5个月之后，我寻找儿童编程语言圣杯的愿望无疾而终，我被迫接受一个非常悲观的事实：30年过去了，QBasic仍然是最适合于编程启蒙的语言，且没有之一。</p><blockquote><p>“天呐，请别教他GOTO！”</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 PRINT “OH NO, WHAT ARE YOU DOING?!!!”</span><br><span class="line">20 GOTO 10</span><br></pre></td></tr></table></figure><p>是的，QBasic确实是一门相当糟糕的过程式编程语言。它将被广泛认为不好的语言特性介绍给所有学习这门语言的人，包括隐式声明语法，不区分大小写，使用non-zero-based<sup>[2]</sup>计数等等。学习编程，最好的做法是从一开始就养成良好的习惯，而非多年之后再来纠正那些不良实践。按照这个逻辑，可能应该从我最爱的Ruby语言开始学习编程。然而，即便QBasic有许多在现在看来不是很恰当的语言特性，但QBasic具备的这些特性，都遵循着一个非常明确的设计目标：保持语言的简单性和易用性，而其他语言常常为了保证灵活性、一定的复杂度和逻辑性抛弃了这两个目标。</p><p>我在Noah的11’’ HP Stream上安装了QBasic，这个过程中还不得不使用了一些DosBox的破解手段。接着Noah双击图标，进入了IDE的介绍界面，这勾起了我很多回忆：</p><p><img src="https://upload.wikimedia.org/wikipedia/en/0/01/QBasic_Opening_Screen.png" alt="img"></p><p>接下来，我向Noah介绍了每一位编程初学者的“神圣的仪式“：开发一个向这个圈子里其他同伴问好的程序。他慢慢地摸索着每一个按键，用右手手指小心翼翼地敲出了一串字符：<code>PRINT &quot;hello world&quot;</code></p><p>他按下了<em>F5</em>键，当他看到自己的代码被编译、渲染到一片漆黑的屏幕上时，Noah显得非常惊喜。他欢笑着给了他老爹一个high-five，然后赶紧把电脑中刚刚敲下的代码抄录到了自己的笔记本上，为了防止自己忘记。</p><p><img src="http://nicolasbize.com/blog/images/noah_1.jpg" alt="img"></p><p>我们继续学习了其他指令：<code>CLS, COLOR, PLAY, INPUT</code>和<code>IF</code>。全程无需任何多余的解释，没有任何复杂度，没有生涩的操作符，没有抽象概念，没有必须仔细阅读的文档和手册，没有<em>object/class/method</em>等高级概念，不用安装任何开发框架，IDE中也没有大片的菜单和按钮，也没有特殊的单词和括号。一切仅仅是格式简单的纯代码。</p><p>不到1个小时，Noah就独立地写出了一个程序——一个交互式的，非常微妙的小程序，这个程序让你明白了计算机对你作为一个有情感的人类个体的感受。</p><p><img src="http://nicolasbize.com/blog/images/noah_3.jpg" alt="img"></p><p>随后他立马邀请来他最好的朋友Christian，并把程序运行给他看，极其自豪。</p><p><img src="http://nicolasbize.com/blog/images/noah_4.jpg" alt="img"></p><p>Noah甚至还给好朋友简单地介绍了这个程序的是如何运行的，以及这些代码的含义！</p><p><img src="http://nicolasbize.com/blog/images/noah_5.jpg" alt="img"></p><p>在这一个小时中，我这年龄才7岁的儿子不仅学会了写第一个纯文本交互游戏，还体验了创造的乐趣和激动，编译并运行了他那个小程序。更值得表演的是，他还将全部的学习成果记录在了笔记本上，这个习惯非常不错：</p><p><img src="http://nicolasbize.com/blog/images/noah_2.jpg" alt="img"></p><p>我很开心的是，今天Noah终于体会到了他爸爸一直在说的“我做着全世界最棒的工作”。而我唯一感到遗憾的是认识到了一个悲观的现实，经过了30多年，我们仍然没有创造出对于儿童编程更适合的编程语言：QBasic只有非常有限的关键字（全部的帮助文档只需一个<em>F1</em>屏，并且还能附上简单的示例），没有任何让程序员分心的可视化组件，具有非常紧凑的开发环境，它能尽可能早地报错，使用简单的一键式编译和运行。这么多年来，我们创造出了更稳定、更复杂的语言/框架/IDE。诚然，对于现实真正的应用开发而言，足够的稳定性和复杂度是必须的，但我们还是没能创造出比QBasic更简单、更容易让初学者感受到编程的快乐的语言。而且在“现代化”的软件生态和环境中，让新手用现代计算机（Mac/PC/Linux）去运行QBasic也变得让人感到恐惧，放在当年，只需要将一个3.5英寸的磁盘插入硬盘驱动即可······</p><p>不论如何，今天值得庆祝的是，又有一位新朋友发现了编程的快乐与美丽！欢呼～</p><p>（按照文章开头的约定，欢迎体验<a href="http://nicolasbize.com/ld34/" target="_blank" rel="noopener">我的AAA大作</a>，而我，就等着EA来向我够买版权了）</p><p>译者注：</p><p>[1] Ludam Dare：Ludam Dare是一个世界级的在线、快速游戏开发挑战活动。要求参与者利用一个周末的时间，基于赛前社区票选出的主题，从零开始制作一款游戏。</p><p>[2] Non-zero-based：Zero-based是一种从0开始的计数方法，相反Non-zero-based计数法是从非零数开始计数，例如从1开始。严格来讲从0开始或从1开始计数并没有对和错之分，但在计算机领域尤其是在编程语言领域，从0开始计数是一个比较常见的惯例，大部分具有一定影响力的编程语言也是这么设计的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;30年之后，QBasic依然是最棒的编程启蒙语言&quot;&gt;&lt;a href=&quot;#30年之后，QBasic依然是最棒的编程启蒙语言&quot; class=&quot;headerlink&quot; title=&quot;30年之后，QBasic依然是最棒的编程启蒙语言&quot;&gt;&lt;/a&gt;30年之后，QBasic依然
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Garbage Collection with LLVM</title>
    <link href="https://chinomars.com/2020/10/28/Garbage-Collection-based-on-LLVM/"/>
    <id>https://chinomars.com/2020/10/28/Garbage-Collection-based-on-LLVM/</id>
    <published>2020-10-27T16:56:36.000Z</published>
    <updated>2020-11-13T13:26:42.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p><strong>TRANSLATION:</strong> 本文内容主要包括如何在一个支持GC的语言编译器中集成LLVM。<strong>需要注意的是，LLVM本身并不提供垃圾回收器。</strong>用户必须先开发一个垃圾回收器。</p><p><strong>ORIGIN:</strong> This document covers how to integrate LLVM into a compiler for a language which supports garbage collection. <strong>Note that LLVM itself does not provide a garbage collector.</strong> You must provide your own.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p><strong>TRANSLATION:</strong> 第一步，我们需要选择一个收集器的收集策略。LLVM内置了一些收集策略，用户也可以自定义一个收集策略，以插件形式集成到LLVM中。需要注意的是，收集策略描述了LLVM如何生成能够与你的收集器和运行时相适配的代码，而非收集器本身。</p><p><strong>ORIGIN:</strong> First, you should pick a collector strategy. LLVM includes a number of built in ones, but you can also implement a loadable plugin with a custom definition. Note that the collector strategy is a description of how LLVM should generate code such that it interacts with your collector and runtime, not a description of the collector itself.</p><p><strong>TRANSLATION:</strong> 接下来，把即将生成的代码标记为你所选择的收集器策略。例如在c++代码中，我们可以调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F.setGC(&lt;collector description name&gt;);</span><br></pre></td></tr></table></figure><p>对应的IR生成将会表示为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define void @foo() gc &quot;&lt;collector description name&gt;&quot; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><strong>ORIGIN:</strong> Next, mark your generated functions as using your chosen collector strategy. From c++, you can call:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F.setGC(&lt;collector description name&gt;);</span><br></pre></td></tr></table></figure><p>This will produce IR like the following fragment:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>() <span class="keyword">gc</span> <span class="string">"&lt;collector description name&gt;"</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><strong>TRANSLATION:</strong> 生成与GC相关的函数对应的IR，我们需要做以下操作：</p><ul><li>使用<code>@llvm.gcread</code>与<code>@llvm.gcwrite</code>来替代标准的<code>load</code>和<code>store</code>指令。这些内嵌函数用于表示<code>load barriers</code>和<code>store  barriers</code>。如果我们的GC收集器并不需要这些<code>barriers</code>，我们也可以跳过这些操作。</li><li>使用我们所需要对接的GC的内存分配器，替换LLVM提供的标准内存分配函数。</li><li>如果我们的收集器收集器还要求生成类型映射表，那么我们还需要在运行时库中添加相应的基础功能与相应的接口。LLVM并不会参与到这一过程。LLVM的类型系统一般情况下也并不适合来做相应的信息收集和统计，尤其是在编译器中做这件事。</li><li>插入任何收集器工作所需要的代码。不少收集器要求程序在运行时阶段性地检查一些标记位，并根据不同的条件调用runtime函数。这通常来源于一些安全点轮询点需求（safepoint poll）。</li></ul><p><strong>ORIGIN:</strong> When generating LLVM IR for your functions, you will need to:</p><ul><li>Use <code>@llvm.gcread</code> and/or <code>@llvm.gcwrite</code> in place of standard load and store instructions. These intrinsics are used to represent load and store barriers. If you collector does not require such barriers, you can skip this step.</li><li>Use the memory allocation routines provided by your garbage collector’s runtime library.</li><li>If your collector requires them, generate type maps according to your runtime’s binary interface. LLVM is not involved in the process. In particular, the LLVM type system is not suitable for conveying such information though the compiler.</li><li>Insert any coordination code required for interacting with your collector. Many collectors require running application code to periodically check a flag and conditionally call a runtime function. This is often referred to as a safepoint poll.</li></ul><p><strong>TRANSLATION:</strong> 我们需要在生成的IR中识别出<code>roots</code>（收集器需要感知到堆对象的引用），这样LLVM可以将它们编码到代码的<code>stack map</code>中。根据不同的收集器策略，通过使用<code>@llvm.gcroot</code>或者一个<code>gc.statepoint</code>重分配语句。</p><p><strong>ORIGIN:</strong> You will need to identify roots (i.e. references to heap objects your collector needs to know about) in your generated IR, so that LLVM can encode them into your final stack maps. Depending on the collector strategy chosen, this is accomplished by using either the <code>@llvm.gcroot</code> intrinsics or an <code>gc.statepoint</code> relocation sequence.</p><p><strong>TRANSLATION:</strong> 在计算一个表达式时，对于计算中的每个中间值都需要为其创建一个<code>root</code>。在函数调用表达式<code>h(f(), g())</code>中，如果在计算<code>g()</code>的时候出发了GC，那么<code>f()</code>的计算结果就可以比较容易的被回收。</p><p><strong>ORIGIN:</strong> Don’t forget to create a root for each intermediate value that is generated when evaluating an expression. In <code>h(f(), g())</code>, the result of <code>f()</code> could easily be collected if evaluating <code>g()</code> triggers a collection.</p><p><strong>TRANSLATION:</strong> 最后，我们需要将<code>runtime</code>库与生成的可执行程序链接起来，或者其他可以保证程序运行时可以调用到<code>runtime</code>库函数的方式也行。</p><p><strong>ORIGIN:</strong> Finally, you need to link your runtime library with the generated program executable (for a static compiler) or ensure the appropriate symbols are available for the runtime linker (for a JIT compiler).</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="What-is-Garbage-Collection"><a href="#What-is-Garbage-Collection" class="headerlink" title="What is Garbage Collection?"></a>What is Garbage Collection?</h3><p><strong>TRANSLATION:</strong> 垃圾回收是一种被广泛使用的技术，可以将程序员从复杂的对象生命周期管理工作中解放出来。垃圾回收技术可以帮助程序更容易运行和维护。很多编程语言都依赖垃圾回收技术来进行内存管理。根据精确度，垃圾回收技术大致可以分为两种：保守式和精确式。</p><p><strong>ORIGIN:</strong> Garbage collection is a widely used technique that frees the programmer from having to know the lifetimes of heap objects, making software easier to produce and maintain. Many programming languages rely on garbage collection for automatic memory management. There are two primary forms of garbage collection: conservative and accurate.</p><p><strong>TRANSLATION:</strong> 保守式垃圾回收技术一般对于编程语言或编译器都没有特殊的要求。即使对于非类型安全的编程语言（例如C/C++），保守式垃圾回收技术也能良好地工作。著名的<strong>Boehm collector</strong>就是一种当前比较先进的保守式垃圾回收算法。</p><p><strong>ORIGIN:</strong> Conservative garbage collection often does not require any special support from either the language or the compiler: it can handle non-type-safe programming languages (such as C/C++) and does not require any special information from the compiler. The <a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/" target="_blank" rel="noopener">Boehm collector</a> is an example of a state-of-the-art conservative collector.</p><p><strong>TRANSLATION:</strong> 精确式垃圾回收技术要求能在程序运行时对所有的指针都能识别，这就要求源语言是类型安全的，才能保证在编译阶段和运行阶段都没有不可控的隐式类型转换。在程序运行时识别所有的指针意味着要求编译器需要支持对所有运行时可能存在的指针进行内存分配，这样我们可以在编译期识别所有的指针，包括程序栈和寄存器。</p><p><strong>ORIGIN:</strong> Accurate garbage collection requires the ability to identify all pointers in the program at run-time (which requires that the source-language be type-safe in most cases). Identifying pointers at run-time requires compiler support to locate all places that hold live pointer variables at run-time, including the <a href="https://llvm.org/docs/GarbageCollection.html#gcroot" target="_blank" rel="noopener">processor stack and registers</a>.</p><p><strong>TRANSLATION:</strong> 保守式垃圾回收是非常吸引人的，因为它不需要编译器的特殊支持，但也存在一定的问题。保守式垃圾回收技术中，收集器无法明确地识别一个目标是否是一个指针，那么它就无法转移这个目标（因此保守式回收技术中无法应用内存压缩和分代的GC算法），同时保守式GC中偶尔也会存在内存泄漏现象，尤其是当一个整数值正好指向了一个对象。此外，一些激进的编译器优化也会破坏保守式垃圾回收器（实践中很少发生）。</p><p><strong>ORIGIN:</strong> Conservative garbage collection is attractive because it does not require any special compiler support, but it does have problems. In particular, because the conservative garbage collector cannot <em>know</em> that a particular word in the machine is a pointer, it cannot move live objects in the heap (preventing the use of compacting and generational GC algorithms) and it can occasionally suffer from memory leaks due to integer values that happen to point to objects in the program. In addition, some aggressive compiler transformations can break conservative garbage collectors (though these seem rare in practice).</p><p><strong>TRANSLATION:</strong> 精确式垃圾回收器不会有任何上述的问题，但会遭遇程序的标量优化退化（scalar optimization）。特别是由于运行时必须能识别并更新所有的活动指针，一些优化效果会下降。所幸的是局部性和使用激进的垃圾回收技术所带来的性能提升能够弥补这些低阶的性能损失。</p><p><strong>ORIGIN:</strong> Accurate garbage collectors do not suffer from any of these problems, but they can suffer from degraded scalar optimization of the program. In particular, because the runtime must be able to identify and update all pointers active in the program, some optimizations are less effective. In practice, however, the locality and performance benefits of using aggressive garbage collection techniques dominates any low-level losses.</p><p><strong>TRANSLATION:</strong> 这份文档描述了LLVM为了支持精确式垃圾回收所提供的机制和接口。</p><p><strong>ORIGIN:</strong> This document describes the mechanisms and interfaces provided by LLVM to support accurate garbage collection.</p><h3 id="Goals-and-non-goals"><a href="#Goals-and-non-goals" class="headerlink" title="Goals and non-goals"></a>Goals and non-goals</h3><p><strong>TRANSLATION:</strong> LLVM的中间表达为很多垃圾回收模型提供了垃圾回收相关固有函数的支持。例如，这些固有函数支持：</p><ul><li>半空间收集器</li><li>标记-清楚收集器</li><li>分代收集器</li><li>递增收集器</li><li>并发收集器</li><li>协作收集器</li><li>引用计数</li></ul><p><strong>ORIGIN:</strong> LLVM’s intermediate representation provides <a href="https://llvm.org/docs/GarbageCollection.html#gc-intrinsics" target="_blank" rel="noopener">garbage collection intrinsics</a> that offer support for a broad class of collector models. For instance, the intrinsics permit:</p><ul><li>semi-space collectors</li><li>mark-sweep collectors</li><li>generational collectors</li><li>incremental collectors</li><li>concurrent collectors</li><li>cooperative collectors</li><li>reference counting</li></ul><p><strong>TRANSLATION:</strong> 我们希望这些LLVM IR中内建的支持能够支持大量的依赖于GC的编程语言，例如 Scheme，ML，Java，C#，Perl，Python，Lua，Ruby以及其他脚本语言。</p><p><strong>ORIGIN:</strong> We hope that the support built into the LLVM IR is sufficient to support a broad class of garbage collected languages including Scheme, ML, Java, C#, Perl, Python, Lua, Ruby, other scripting languages, and more.</p><p><strong>TRANSLATION:</strong> 请注意，LLVM自身并不提供垃圾收集器，垃圾收集器应该属于语言运行时库的一部分。LLVM提供了一个描述垃圾收集器对编译器需求的框架。特别的，LLVM支持在调用点生成stack map、轮询安全点以及生成load&amp;stroe栅。我们也可以通过代码生成插件来扩展LLVM，在二进制接口中生成runtime库所定义的代码和数据结构。这跟DWARF调试信息和LLVM的关系类似。唯一的区别在于，DWARF有相对标准的规范，而垃圾回收没有，这也要求LLVM提供一个相对灵活的扩展机制。</p><p><strong>ORIGIN:</strong> Note that LLVM <strong>does not itself provide a garbage collector</strong> — this should be part of your language’s runtime library. LLVM provides a framework for describing the garbage collectors requirements to the compiler. In particular, LLVM provides support for generating stack maps at call sites, polling for a safepoint, and emitting load and store barriers. You can also extend LLVM - possibly through a loadable <a href="https://llvm.org/docs/GarbageCollection.html#plugin" target="_blank" rel="noopener">code generation plugins</a> - to generate code and data structures which conforms to the <em>binary interface</em> specified by the <em>runtime library</em>. This is similar to the relationship between LLVM and DWARF debugging info, for example. The difference primarily lies in the lack of an established standard in the domain of garbage collection — thus the need for a flexible extension mechanism.</p><p><strong>TRANSLATION:</strong> LLVM对GC的支持所关注的二进制接口包括：</p><ul><li>在代码中创建GC安全点，帮助GC可以安全地执行；</li><li>栈映射的计算。对于代码中的每个安全点，栈帧中的对象引用都必须被识别出来，这样收集器才能遍历它们，并适时地更新它们；</li><li>在写入堆对象引用时的写栅栏。这些写栅栏普遍被用于分代收集器中进行递增式扫描；</li><li>在读取对象应用时发布读栅栏。这对于与并发收集器的互操作是很有用的。</li></ul><p><strong>ORIGIN:</strong> The aspects of the binary interface with which LLVM’s GC support is concerned are:</p><ul><li>Creation of GC safepoints within code where collection is allowed to execute safely.</li><li>Computation of the stack map. For each safe point in the code, object references within the stack frame must be identified so that the collector may traverse and perhaps update them.</li><li>Write barriers when storing object references to the heap. These are commonly used to optimize incremental scans in generational collectors.</li><li>Emission of read barriers when loading object references. These are useful for interoperating with concurrent collectors.</li></ul><p><strong>TRANSLATION:</strong> LLVM没有直接处理和解决的领域有：</p><ul><li>将全局根注册到运行时；</li><li>将栈映射入口注册到运行时；</li><li>程序运行过程中的内存分配函数、垃圾回收触发函数等；</li><li>类型映射表的计算或编译，或者将它们注册到运行时也为涉及。这些一般用于在堆中获取对象的引用。</li></ul><p><strong>ORIGIN:</strong> There are additional areas that LLVM does not directly address:</p><ul><li>Registration of global roots with the runtime.</li><li>Registration of stack map entries with the runtime.</li><li>The functions used by the program to allocate memory, trigger a collection, etc.</li><li>Computation or compilation of type maps, or registration of them with the runtime. These are used to crawl the heap for object references.</li></ul><p><strong>TRANSLATION:</strong> 总体来讲，LLVM对GC的支持不包括那些可以通过其他IR特性可以解决的方面，LLVM也不提供相应的二进制接口。这也意味着我们必须将一个已有的运行时库与LLVM集成到一起。此外，这也会给创造一门全新的语言带来非常多的工作量。通过提供内建的收集器策略描述，这样能够与大部分普通的收集器协同工作，以及一些容易扩展的点来缓和上述难点。如果你没有什么需要特殊支持的二进制接口，那么建议你可以选择一个内建收集器策略。</p><p><strong>ORIGIN:</strong> In general, LLVM’s support for GC does not include features which can be adequately addressed with other features of the IR and does not specify a particular binary interface. On the plus side, this means that you should be able to integrate LLVM with an existing runtime. On the other hand, it can have the effect of leaving a lot of work for the developer of a novel language. We try to mitigate this by providing built in collector strategy descriptions that can work with many common collector designs and easy extension points. If you don’t already have a specific binary interface you need to support, we recommend trying to use one of these built in collector strategies.</p><h2 id="LLVM-IR-Features"><a href="#LLVM-IR-Features" class="headerlink" title="LLVM IR Features"></a>LLVM IR Features</h2><p><strong>TRANSLATION:</strong> 本节描述LLVM IR提供的垃圾回收基础设施。这些IR特性具体的表现由用户所选择的不同GC策略描述定义与明确。</p><p><strong>ORIGIN:</strong> This section describes the garbage collection facilities provided by the <a href="https://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">LLVM intermediate representation</a>. The exact behavior of these IR features is specified by the selected <a href="https://llvm.org/docs/GarbageCollection.html#plugin" target="_blank" rel="noopener">GC strategy description</a>.</p><h3 id="Specifying-GC-code-generation-gc-quot-quot"><a href="#Specifying-GC-code-generation-gc-quot-quot" class="headerlink" title="Specifying GC code generation: gc &quot;...&quot;"></a>Specifying GC code generation: <code>gc &quot;...&quot;</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define &lt;returntype&gt; @name(...) gc &quot;name&quot; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><strong>TRANSLATION:</strong> GC函数属性用于指定编译器所对接的GC策略。在程序上等价于<code>Function</code>的<code>setGC</code>方法。</p><p><strong>ORIGIN:</strong> The <code>gc</code> function attribute is used to specify the desired GC strategy to the compiler. Its programmatic equivalent is the <code>setGC</code> method of <code>Function</code>.</p><p><strong>TRANSLATION:</strong> 对一个函数设置“name”会触发对GC策略的子集的搜索。某些收集器策略是内置的。我们也可以通过一个可扩展的插件机制来自定义添加新的GC策略，当然也可以通过给LLVM加Patch的方式来扩展。GC策略定义了所生成代码的具体的行为，来支持GC。如果搜索失败，编译器会报错。</p><p><strong>ORIGIN:</strong> Setting <code>gc &quot;name&quot;</code> on a function triggers a search for a matching subclass of GCStrategy. Some collector strategies are built in. You can add others using either the loadable plugin mechanism, or by patching your copy of LLVM. It is the selected GC strategy which defines the exact nature of the code generated to support GC. If none is found, the compiler will raise an error.</p><p><strong>TRANSLATION:</strong> </p><p><strong>ORIGIN:</strong> Specifying the GC style on a per-function basis allows LLVM to link together programs that use different garbage collection algorithms (or none at all).</p><h3 id="Identifying-GC-roots-on-the-stack"><a href="#Identifying-GC-roots-on-the-stack" class="headerlink" title="Identifying GC roots on the stack"></a>Identifying GC roots on the stack</h3><h4 id="Using-gc-safepoint"><a href="#Using-gc-safepoint" class="headerlink" title="Using gc.safepoint"></a>Using <code>gc.safepoint</code></h4><p><a href="https://llvm.org/docs/Statepoints.html" target="_blank" rel="noopener">This page</a> contains detailed documentation for <code>gc.statepoint</code>.</p><h4 id="Using-llvm-gcwrite"><a href="#Using-llvm-gcwrite" class="headerlink" title="Using llvm.gcwrite"></a>Using <code>llvm.gcwrite</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void @llvm.gcroot(i8** %ptrloc, i8* %metadata)</span><br></pre></td></tr></table></figure><p>The <code>llvm.gcroot</code> intrinsic is used to inform LLVM that a stack variable references an object on the heap and is to be tracked for garbage collection. The exact impact on generated code is specified by the Function’s selected <a href="https://llvm.org/docs/GarbageCollection.html#plugin" target="_blank" rel="noopener">GC strategy</a>. All calls to <code>llvm.gcroot</code> <strong>must</strong> reside inside the first basic block.</p><p>The first argument <strong>must</strong> be a value referring to an alloca instruction or a bitcast of an alloca. The second contains a pointer to metadata that should be associated with the pointer, and <strong>must</strong> be a constant or global value address. If your target collector uses tags, use a null pointer for metadata.</p><p>A compiler which performs manual SSA construction <strong>must</strong> ensure that SSA values representing GC references are stored in to the alloca passed to the respective <code>gcroot</code> before every call site and reloaded after every call. A compiler which uses mem2reg to raise imperative code using <code>alloca</code> into SSA form need only add a call to <code>@llvm.gcroot</code> for those variables which are pointers into the GC heap.</p><p>It is also important to mark intermediate values with <code>llvm.gcroot</code>. For example, consider <code>h(f(), g())</code>. Beware leaking the result of <code>f()</code> in the case that <code>g()</code> triggers a collection. Note, that stack variables must be initialized and marked with <code>llvm.gcroot</code> in function’s prologue.</p><p>The <code>%metadata</code> argument can be used to avoid requiring heap objects to have ‘isa’ pointers or tag bits. [<a href="https://llvm.org/docs/GarbageCollection.html#appel89" target="_blank" rel="noopener">Appel89</a>, <a href="https://llvm.org/docs/GarbageCollection.html#goldberg91" target="_blank" rel="noopener">Goldberg91</a>, <a href="https://llvm.org/docs/GarbageCollection.html#tolmach94" target="_blank" rel="noopener">Tolmach94</a>] If specified, its value will be tracked along with the location of the pointer in the stack frame.</p><p>Consider the following fragment of Java code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  Object X;   &#x2F;&#x2F; A null-initialized reference to an object</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This block (which may be located in the middle of a function or in a loop nest), could be compiled to this LLVM code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Entry:</span><br><span class="line">   ;; In the entry block for the function, allocate the</span><br><span class="line">   ;; stack space for X, which is an LLVM pointer.</span><br><span class="line">   %X &#x3D; alloca %Object*</span><br><span class="line"></span><br><span class="line">   ;; Tell LLVM that the stack space is a stack root.</span><br><span class="line">   ;; Java has type-tags on objects, so we pass null as metadata.</span><br><span class="line">   %tmp &#x3D; bitcast %Object** %X to i8**</span><br><span class="line">   call void @llvm.gcroot(i8** %tmp, i8* null)</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   ;; &quot;CodeBlock&quot; is the block corresponding to the start</span><br><span class="line">   ;;  of the scope above.</span><br><span class="line">CodeBlock:</span><br><span class="line">   ;; Java null-initializes pointers.</span><br><span class="line">   store %Object* null, %Object** %X</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   ;; As the pointer goes out of scope, store a null value into</span><br><span class="line">   ;; it, to indicate that the value is no longer live.</span><br><span class="line">   store %Object* null, %Object** %X</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><h3 id="Reading-and-writing-references-in-the-heap"><a href="#Reading-and-writing-references-in-the-heap" class="headerlink" title="Reading and writing references in the heap"></a>Reading and writing references in the heap</h3><p>Some collectors need to be informed when the mutator (the program that needs garbage collection) either reads a pointer from or writes a pointer to a field of a heap object. The code fragments inserted at these points are called <em>read barriers</em> and <em>write barriers</em>, respectively. The amount of code that needs to be executed is usually quite small and not on the critical path of any computation, so the overall performance impact of the barrier is tolerable.</p><p>Barriers often require access to the <em>object pointer</em> rather than the <em>derived pointer</em> (which is a pointer to the field within the object). Accordingly, these intrinsics take both pointers as separate arguments for completeness. In this snippet, <code>%object</code> is the object pointer, and <code>%derived</code> is the derived pointer:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;; An array type.</span><br><span class="line">%class.Array &#x3D; type &#123; %class.Object, i32, [0 x %class.Object*] &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">;; Load the object pointer from a gcroot.</span><br><span class="line">%object &#x3D; load %class.Array** %object_addr</span><br><span class="line"></span><br><span class="line">;; Compute the derived pointer.</span><br><span class="line">%derived &#x3D; getelementptr %object, i32 0, i32 2, i32 %n</span><br></pre></td></tr></table></figure><p>LLVM does not enforce this relationship between the object and derived pointer (although a particular <a href="https://llvm.org/docs/GarbageCollection.html#plugin" target="_blank" rel="noopener">collector strategy</a> might). However, it would be an unusual collector that violated it.</p><p>The use of these intrinsics is naturally optional if the target GC does not require the corresponding barrier. The GC strategy used with such a collector should replace the intrinsic calls with the corresponding <code>load</code> or <code>store</code> instruction if they are used.</p><p>One known deficiency with the current design is that the barrier intrinsics do not include the size or alignment of the underlying operation performed. It is currently assumed that the operation is of pointer size and the alignment is assumed to be the target machine’s default alignment.</p><h4 id="Write-barrier-llvm-gcwrite"><a href="#Write-barrier-llvm-gcwrite" class="headerlink" title="Write barrier: llvm.gcwrite"></a>Write barrier: <code>llvm.gcwrite</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void @llvm.gcwrite(i8* %value, i8* %object, i8** %derived)</span><br></pre></td></tr></table></figure><p>For write barriers, LLVM provides the <code>llvm.gcwrite</code> intrinsic function. It has exactly the same semantics as a non-volatile <code>store</code> to the derived pointer (the third argument). The exact code generated is specified by the Function’s selected <a href="https://llvm.org/docs/GarbageCollection.html#plugin" target="_blank" rel="noopener">GC strategy</a>.</p><p>Many important algorithms require write barriers, including generational and concurrent collectors. Additionally, write barriers could be used to implement reference counting.</p><h4 id="Read-barrier-llvm-gcread"><a href="#Read-barrier-llvm-gcread" class="headerlink" title="Read barrier: llvm.gcread"></a>Read barrier: <code>llvm.gcread</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i8* @llvm.gcread(i8* %object, i8** %derived)</span><br></pre></td></tr></table></figure><p>For read barriers, LLVM provides the <code>llvm.gcread</code> intrinsic function. It has exactly the same semantics as a non-volatile <code>load</code> from the derived pointer (the second argument). The exact code generated is specified by the Function’s selected <a href="https://llvm.org/docs/GarbageCollection.html#plugin" target="_blank" rel="noopener">GC strategy</a>.</p><p>Read barriers are needed by fewer algorithms than write barriers, and may have a greater performance impact since pointer reads are more frequent than writes.</p><h2 id="Built-In-GC-Strategies"><a href="#Built-In-GC-Strategies" class="headerlink" title="Built In GC Strategies"></a>Built In GC Strategies</h2><p>LLVM includes built in support for several varieties of garbage collectors.</p><h3 id="The-Shadow-Stack-GC"><a href="#The-Shadow-Stack-GC" class="headerlink" title="The Shadow Stack GC"></a>The Shadow Stack GC</h3><p>To use this collector strategy, mark your functions with:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F.setGC(&quot;shadow-stack&quot;);</span><br></pre></td></tr></table></figure><p>Unlike many GC algorithms which rely on a cooperative code generator to compile stack maps, this algorithm carefully maintains a linked list of stack roots [<a href="https://llvm.org/docs/GarbageCollection.html#henderson02" target="_blank" rel="noopener">Henderson2002</a>]. This so-called “shadow stack” mirrors the machine stack. Maintaining this data structure is slower than using a stack map compiled into the executable as constant data, but has a significant portability advantage because it requires no special support from the target code generator, and does not require tricky platform-specific code to crawl the machine stack.</p><p>The tradeoff for this simplicity and portability is:</p><ul><li>High overhead per function call.</li><li>Not thread-safe.</li></ul><p>Still, it’s an easy way to get started. After your compiler and runtime are up and running, writing a <a href="https://llvm.org/docs/GarbageCollection.html#plugin" target="_blank" rel="noopener">plugin</a> will allow you to take advantage of <a href="https://llvm.org/docs/GarbageCollection.html#collector-algos" target="_blank" rel="noopener">more advanced GC features</a> of LLVM in order to improve performance.</p><p>The shadow stack doesn’t imply a memory allocation algorithm. A semispace collector or building atop <code>malloc</code> are great places to start, and can be implemented with very little code.</p><p>When it comes time to collect, however, your runtime needs to traverse the stack roots, and for this it needs to integrate with the shadow stack. Luckily, doing so is very simple. (This code is heavily commented to help you understand the data structure, but there are only 20 lines of meaningful code.)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; The map for a single function&#39;s stack frame.  One of these is</span><br><span class="line">&#x2F;&#x2F;&#x2F;        compiled as constant data into the executable for each function.</span><br><span class="line">&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;&#x2F; Storage of metadata values is elided if the %metadata parameter to</span><br><span class="line">&#x2F;&#x2F;&#x2F; @llvm.gcroot is null.</span><br><span class="line">struct FrameMap &#123;</span><br><span class="line">  int32_t NumRoots;    &#x2F;&#x2F;&lt; Number of roots in stack frame.</span><br><span class="line">  int32_t NumMeta;     &#x2F;&#x2F;&lt; Number of metadata entries.  May be &lt; NumRoots.</span><br><span class="line">  const void *Meta[0]; &#x2F;&#x2F;&lt; Metadata for each root.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; A link in the dynamic shadow stack.  One of these is embedded in</span><br><span class="line">&#x2F;&#x2F;&#x2F;        the stack frame of each function on the call stack.</span><br><span class="line">struct StackEntry &#123;</span><br><span class="line">  StackEntry *Next;    &#x2F;&#x2F;&lt; Link to next stack entry (the caller&#39;s).</span><br><span class="line">  const FrameMap *Map; &#x2F;&#x2F;&lt; Pointer to constant FrameMap.</span><br><span class="line">  void *Roots[0];      &#x2F;&#x2F;&lt; Stack roots (in-place array).</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; The head of the singly-linked list of StackEntries.  Functions push</span><br><span class="line">&#x2F;&#x2F;&#x2F;        and pop onto this in their prologue and epilogue.</span><br><span class="line">&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;&#x2F; Since there is only a global list, this technique is not threadsafe.</span><br><span class="line">StackEntry *llvm_gc_root_chain;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; Calls Visitor(root, meta) for each GC root on the stack.</span><br><span class="line">&#x2F;&#x2F;&#x2F;        root and meta are exactly the values passed to</span><br><span class="line">&#x2F;&#x2F;&#x2F;        @llvm.gcroot.</span><br><span class="line">&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;&#x2F; Visitor could be a function to recursively mark live objects.  Or it</span><br><span class="line">&#x2F;&#x2F;&#x2F; might copy them to another heap or generation.</span><br><span class="line">&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;&#x2F; @param Visitor A function to invoke for every GC root on the stack.</span><br><span class="line">void visitGCRoots(void (*Visitor)(void **Root, const void *Meta)) &#123;</span><br><span class="line">  for (StackEntry *R &#x3D; llvm_gc_root_chain; R; R &#x3D; R-&gt;Next) &#123;</span><br><span class="line">    unsigned i &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; For roots [0, NumMeta), the metadata pointer is in the FrameMap.</span><br><span class="line">    for (unsigned e &#x3D; R-&gt;Map-&gt;NumMeta; i !&#x3D; e; ++i)</span><br><span class="line">      Visitor(&amp;R-&gt;Roots[i], R-&gt;Map-&gt;Meta[i]);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; For roots [NumMeta, NumRoots), the metadata pointer is null.</span><br><span class="line">    for (unsigned e &#x3D; R-&gt;Map-&gt;NumRoots; i !&#x3D; e; ++i)</span><br><span class="line">      Visitor(&amp;R-&gt;Roots[i], NULL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="The-‘Erlang’-and-‘Ocaml’-GCs"><a href="#The-‘Erlang’-and-‘Ocaml’-GCs" class="headerlink" title="The ‘Erlang’ and ‘Ocaml’ GCs"></a>The ‘Erlang’ and ‘Ocaml’ GCs</h3><p>LLVM ships with two example collectors which leverage the <code>gcroot</code> mechanisms. To our knowledge, these are not actually used by any language runtime, but they do provide a reasonable starting point for someone interested in writing an <code>gcroot</code> compatible GC plugin. In particular, these are the only in tree examples of how to produce a custom binary stack map format using a <code>gcroot</code> strategy.</p><p>As there names imply, the binary format produced is intended to model that used by the Erlang and OCaml compilers respectively.</p><h3 id="The-Statepoint-Example-GC"><a href="#The-Statepoint-Example-GC" class="headerlink" title="The Statepoint Example GC"></a>The Statepoint Example GC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F.setGC(&quot;statepoint-example&quot;);</span><br></pre></td></tr></table></figure><p>This GC provides an example of how one might use the infrastructure provided by <code>gc.statepoint</code>. This example GC is compatible with the <a href="https://llvm.org/docs/Statepoints.html#placesafepoints" target="_blank" rel="noopener">PlaceSafepoints</a> and <a href="https://llvm.org/docs/Statepoints.html#rewritestatepointsforgc" target="_blank" rel="noopener">RewriteStatepointsForGC</a> utility passes which simplify <code>gc.statepoint</code> sequence insertion. If you need to build a custom GC strategy around the <code>gc.statepoints</code> mechanisms, it is recommended that you use this one as a starting point.</p><p>This GC strategy does not support read or write barriers. As a result, these intrinsics are lowered to normal loads and stores.</p><p>The stack map format generated by this GC strategy can be found in the <a href="https://llvm.org/docs/StackMaps.html#stackmap-section" target="_blank" rel="noopener">Stack Map Section</a> using a format documented <a href="https://llvm.org/docs/Statepoints.html#statepoint-stackmap-format" target="_blank" rel="noopener">here</a>. This format is intended to be the standard format supported by LLVM going forward.</p><h3 id="The-CoreCLR-GC"><a href="#The-CoreCLR-GC" class="headerlink" title="The CoreCLR GC"></a>The CoreCLR GC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F.setGC(&quot;coreclr&quot;);</span><br></pre></td></tr></table></figure><p>This GC leverages the <code>gc.statepoint</code> mechanism to support the <a href="https://github.com/dotnet/coreclr" target="_blank" rel="noopener">CoreCLR</a> runtime.</p><p>Support for this GC strategy is a work in progress. This strategy will differ from <a href="https://llvm.org/docs/GarbageCollection.html#statepoint-example-gc" target="_blank" rel="noopener">statepoint-example GC</a> strategy in certain aspects like:</p><ul><li>Base-pointers of interior pointers are not explicitly tracked and reported.</li><li>A different format is used for encoding stack maps.</li><li>Safe-point polls are only needed before loop-back edges and before tail-calls (not needed at function-entry).</li></ul><h2 id="Custom-GC-Strategies"><a href="#Custom-GC-Strategies" class="headerlink" title="Custom GC Strategies"></a>Custom GC Strategies</h2><p>If none of the built in GC strategy descriptions met your needs above, you will need to define a custom GCStrategy and possibly, a custom LLVM pass to perform lowering. Your best example of where to start defining a custom GCStrategy would be to look at one of the built in strategies.</p><p>You may be able to structure this additional code as a loadable plugin library. Loadable plugins are sufficient if all you need is to enable a different combination of built in functionality, but if you need to provide a custom lowering pass, you will need to build a patched version of LLVM. If you think you need a patched build, please ask for advice on llvm-dev. There may be an easy way we can extend the support to make it work for your use case without requiring a custom build.</p><h3 id="Collector-Requirements"><a href="#Collector-Requirements" class="headerlink" title="Collector Requirements"></a>Collector Requirements</h3><p>You should be able to leverage any existing collector library that includes the following elements:</p><ol><li>A memory allocator which exposes an allocation function your compiled code can call.</li><li>A binary format for the stack map. A stack map describes the location of references at a safepoint and is used by precise collectors to identify references within a stack frame on the machine stack. Note that collectors which conservatively scan the stack don’t require such a structure.</li><li>A stack crawler to discover functions on the call stack, and enumerate the references listed in the stack map for each call site.</li><li>A mechanism for identifying references in global locations (e.g. global variables).</li><li>If you collector requires them, an LLVM IR implementation of your collectors load and store barriers. Note that since many collectors don’t require barriers at all, LLVM defaults to lowering such barriers to normal loads and stores unless you arrange otherwise.</li></ol><h3 id="Implementing-a-collector-plugin"><a href="#Implementing-a-collector-plugin" class="headerlink" title="Implementing a collector plugin"></a>Implementing a collector plugin</h3><p>User code specifies which GC code generation to use with the <code>gc</code> function attribute or, equivalently, with the <code>setGC</code> method of <code>Function</code>.</p><p>To implement a GC plugin, it is necessary to subclass <code>llvm::GCStrategy</code>, which can be accomplished in a few lines of boilerplate code. LLVM’s infrastructure provides access to several important algorithms. For an uncontroversial collector, all that remains may be to compile LLVM’s computed stack map to assembly code (using the binary representation expected by the runtime library). This can be accomplished in about 100 lines of code.</p><p>This is not the appropriate place to implement a garbage collected heap or a garbage collector itself. That code should exist in the language’s runtime library. The compiler plugin is responsible for generating code which conforms to the binary interface defined by library, most essentially the <a href="https://llvm.org/docs/GarbageCollection.html#stack-map" target="_blank" rel="noopener">stack map</a>.</p><p>To subclass <code>llvm::GCStrategy</code> and register it with the compiler:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; lib&#x2F;MyGC&#x2F;MyGC.cpp - Example LLVM GC plugin</span><br><span class="line"></span><br><span class="line">#include &quot;llvm&#x2F;CodeGen&#x2F;GCStrategy.h&quot;</span><br><span class="line">#include &quot;llvm&#x2F;CodeGen&#x2F;GCMetadata.h&quot;</span><br><span class="line">#include &quot;llvm&#x2F;Support&#x2F;Compiler.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace llvm;</span><br><span class="line"></span><br><span class="line">namespace &#123;</span><br><span class="line">  class LLVM_LIBRARY_VISIBILITY MyGC : public GCStrategy &#123;</span><br><span class="line">  public:</span><br><span class="line">    MyGC() &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  GCRegistry::Add&lt;MyGC&gt;</span><br><span class="line">  X(&quot;mygc&quot;, &quot;My bespoke garbage collector.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This boilerplate collector does nothing. More specifically:</p><ul><li><code>llvm.gcread</code> calls are replaced with the corresponding <code>load</code> instruction.</li><li><code>llvm.gcwrite</code> calls are replaced with the corresponding <code>store</code> instruction.</li><li>No safe points are added to the code.</li><li>The stack map is not compiled into the executable.</li></ul><p>Using the LLVM makefiles, this code can be compiled as a plugin using a simple makefile:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># lib&#x2F;MyGC&#x2F;Makefile</span><br><span class="line"></span><br><span class="line">LEVEL :&#x3D; ..&#x2F;..</span><br><span class="line">LIBRARYNAME &#x3D; MyGC</span><br><span class="line">LOADABLE_MODULE &#x3D; 1</span><br><span class="line"></span><br><span class="line">include $(LEVEL)&#x2F;Makefile.common</span><br></pre></td></tr></table></figure><p>Once the plugin is compiled, code using it may be compiled using <code>llc -load=MyGC.so</code> (though MyGC.so may have some other platform-specific extension):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat sample.ll</span><br><span class="line">define void @f() gc &quot;mygc&quot; &#123;</span><br><span class="line">entry:</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line">$ llvm-as &lt; sample.ll | llc -load&#x3D;MyGC.so</span><br></pre></td></tr></table></figure><p>It is also possible to statically link the collector plugin into tools, such as a language-specific compiler front-end.</p><h3 id="Overview-of-available-features"><a href="#Overview-of-available-features" class="headerlink" title="Overview of available features"></a>Overview of available features</h3><p><code>GCStrategy</code> provides a range of features through which a plugin may do useful work. Some of these are callbacks, some are algorithms that can be enabled, disabled, or customized. This matrix summarizes the supported (and planned) features and correlates them with the collection techniques which typically require them.</p><p>To be clear, the collection techniques above are defined as:</p><ul><li><p>Shadow Stack</p><p>The mutator carefully maintains a linked list of stack roots.</p></li><li><p>Reference Counting</p><p>The mutator maintains a reference count for each object and frees an object when its count falls to zero.</p></li><li><p>Mark-Sweep</p><p>When the heap is exhausted, the collector marks reachable objects starting from the roots, then deallocates unreachable objects in a sweep phase.</p></li><li><p>Copying</p><p>As reachability analysis proceeds, the collector copies objects from one heap area to another, compacting them in the process. Copying collectors enable highly efficient “bump pointer” allocation and can improve locality of reference.</p></li><li><p>Incremental</p><p>(Including generational collectors.) Incremental collectors generally have all the properties of a copying collector (regardless of whether the mature heap is compacting), but bring the added complexity of requiring write barriers.</p></li><li><p>Threaded</p><p>Denotes a multithreaded mutator; the collector must still stop the mutator (“stop the world”) before beginning reachability analysis. Stopping a multithreaded mutator is a complicated problem. It generally requires highly platform-specific code in the runtime, and the production of carefully designed machine code at safe points.</p></li><li><p>Concurrent</p><p>In this technique, the mutator and the collector run concurrently, with the goal of eliminating pause times. In a <em>cooperative</em> collector, the mutator further aids with collection should a pause occur, allowing collection to take advantage of multiprocessor hosts. The “stop the world” problem of threaded collectors is generally still present to a limited extent. Sophisticated marking algorithms are necessary. Read barriers may be necessary.</p></li></ul><p>As the matrix indicates, LLVM’s garbage collection infrastructure is already suitable for a wide variety of collectors, but does not currently extend to multithreaded programs. This will be added in the future as there is interest.</p><table><thead><tr><th align="left">Algorithm</th><th align="left">Done</th><th align="left">Shadow stack</th><th align="left">refcount</th><th align="left">mark- sweep</th><th align="left">copying</th><th align="left">incremental</th><th align="left">threaded</th><th align="left">concurrent</th></tr></thead><tbody><tr><td align="left">stack map</td><td align="left">✔</td><td align="left"></td><td align="left"></td><td align="left">✘</td><td align="left">✘</td><td align="left">✘</td><td align="left">✘</td><td align="left">✘</td></tr><tr><td align="left">initialize roots</td><td align="left">✔</td><td align="left">✘</td><td align="left">✘</td><td align="left">✘</td><td align="left">✘</td><td align="left">✘</td><td align="left">✘</td><td align="left">✘</td></tr><tr><td align="left">derived pointers</td><td align="left">NO</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"><strong>N*</strong></td><td align="left"><strong>N*</strong></td></tr><tr><td align="left"><strong>custom lowering</strong></td><td align="left">✔</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><em>gcroot</em></td><td align="left">✔</td><td align="left">✘</td><td align="left">✘</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><em>gcwrite</em></td><td align="left">✔</td><td align="left"></td><td align="left">✘</td><td align="left"></td><td align="left"></td><td align="left">✘</td><td align="left"></td><td align="left">✘</td></tr><tr><td align="left"><em>gcread</em></td><td align="left">✔</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">✘</td></tr><tr><td align="left"><strong>safe points</strong></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><em>in calls</em></td><td align="left">✔</td><td align="left"></td><td align="left"></td><td align="left">✘</td><td align="left">✘</td><td align="left">✘</td><td align="left">✘</td><td align="left">✘</td></tr><tr><td align="left"><em>before calls</em></td><td align="left">✔</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">✘</td><td align="left">✘</td></tr><tr><td align="left"><em>for loops</em></td><td align="left">NO</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"><strong>N</strong></td><td align="left"><strong>N</strong></td></tr><tr><td align="left"><em>before escape</em></td><td align="left">✔</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">✘</td><td align="left">✘</td></tr><tr><td align="left">emit code at safe points</td><td align="left">NO</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"><strong>N</strong></td><td align="left"><strong>N</strong></td></tr><tr><td align="left"><strong>output</strong></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><em>assembly</em></td><td align="left">✔</td><td align="left"></td><td align="left"></td><td align="left">✘</td><td align="left">✘</td><td align="left">✘</td><td align="left">✘</td><td align="left">✘</td></tr><tr><td align="left"><em>JIT</em></td><td align="left">NO</td><td align="left"></td><td align="left"></td><td align="left"><strong>?</strong></td><td align="left"><strong>?</strong></td><td align="left"><strong>?</strong></td><td align="left"><strong>?</strong></td><td align="left"><strong>?</strong></td></tr><tr><td align="left"><em>obj</em></td><td align="left">NO</td><td align="left"></td><td align="left"></td><td align="left"><strong>?</strong></td><td align="left"><strong>?</strong></td><td align="left"><strong>?</strong></td><td align="left"><strong>?</strong></td><td align="left"><strong>?</strong></td></tr><tr><td align="left">live analysis</td><td align="left">NO</td><td align="left"></td><td align="left"></td><td align="left"><strong>?</strong></td><td align="left"><strong>?</strong></td><td align="left"><strong>?</strong></td><td align="left"><strong>?</strong></td><td align="left"><strong>?</strong></td></tr><tr><td align="left">register map</td><td align="left">NO</td><td align="left"></td><td align="left"></td><td align="left"><strong>?</strong></td><td align="left"><strong>?</strong></td><td align="left"><strong>?</strong></td><td align="left"><strong>?</strong></td><td align="left"><strong>?</strong></td></tr><tr><td align="left">* Derived pointers only pose a hasard to copying collections.</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><strong>?</strong> denotes a feature which could be utilized if available.</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="Computing-stack-maps"><a href="#Computing-stack-maps" class="headerlink" title="Computing stack maps"></a>Computing stack maps</h3><p>LLVM automatically computes a stack map. One of the most important features of a <code>GCStrategy</code> is to compile this information into the executable in the binary representation expected by the runtime library.</p><p>The stack map consists of the location and identity of each GC root in the each function in the module. For each root:</p><ul><li><code>RootNum</code>: The index of the root.</li><li><code>StackOffset</code>: The offset of the object relative to the frame pointer.</li><li><code>RootMetadata</code>: The value passed as the <code>%metadata</code> parameter to the <code>@llvm.gcroot</code> intrinsic.</li></ul><p>Also, for the function as a whole:</p><ul><li><ul><li><p><code>getFrameSize()</code>: The overall size of the function’s initial stack frame,</p><p>not accounting for any dynamic allocation.</p></li></ul></li><li><p><code>roots_size()</code>: The count of roots in the function.</p></li></ul><p>To access the stack map, use <code>GCFunctionMetadata::roots_begin()</code> and -<code>end()</code> from the <a href="https://llvm.org/docs/GarbageCollection.html#assembly" target="_blank" rel="noopener">GCMetadataPrinter</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (iterator I &#x3D; begin(), E &#x3D; end(); I !&#x3D; E; ++I) &#123;</span><br><span class="line">  GCFunctionInfo *FI &#x3D; *I;</span><br><span class="line">  unsigned FrameSize &#x3D; FI-&gt;getFrameSize();</span><br><span class="line">  size_t RootCount &#x3D; FI-&gt;roots_size();</span><br><span class="line"></span><br><span class="line">  for (GCFunctionInfo::roots_iterator RI &#x3D; FI-&gt;roots_begin(),</span><br><span class="line">                                      RE &#x3D; FI-&gt;roots_end();</span><br><span class="line">                                      RI !&#x3D; RE; ++RI) &#123;</span><br><span class="line">    int RootNum &#x3D; RI-&gt;Num;</span><br><span class="line">    int RootStackOffset &#x3D; RI-&gt;StackOffset;</span><br><span class="line">    Constant *RootMetadata &#x3D; RI-&gt;Metadata;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If the <code>llvm.gcroot</code> intrinsic is eliminated before code generation by a custom lowering pass, LLVM will compute an empty stack map. This may be useful for collector plugins which implement reference counting or a shadow stack.</p><h3 id="Initializing-roots-to-null"><a href="#Initializing-roots-to-null" class="headerlink" title="Initializing roots to null"></a>Initializing roots to null</h3><p>It is recommended that frontends initialize roots explicitly to avoid potentially confusing the optimizer. This prevents the GC from visiting uninitialized pointers, which will almost certainly cause it to crash.</p><p>As a fallback, LLVM will automatically initialize each root to <code>null</code> upon entry to the function. Support for this mode in code generation is largely a legacy detail to keep old collector implementations working.</p><h3 id="Custom-lowering-of-intrinsics"><a href="#Custom-lowering-of-intrinsics" class="headerlink" title="Custom lowering of intrinsics"></a><a href="https://llvm.org/docs/GarbageCollection.html#id25" target="_blank" rel="noopener">Custom lowering of intrinsics</a></h3><p>For GCs which use barriers or unusual treatment of stack roots, the implementor is responsibly for providing a custom pass to lower the intrinsics with the desired semantics. If you have opted in to custom lowering of a particular intrinsic your pass <strong>must</strong> eliminate all instances of the corresponding intrinsic in functions which opt in to your GC. The best example of such a pass is the ShadowStackGC and it’s ShadowStackGCLowering pass.</p><p>There is currently no way to register such a custom lowering pass without building a custom copy of LLVM.</p><h3 id="Generating-safe-points"><a href="#Generating-safe-points" class="headerlink" title="Generating safe points"></a>Generating safe points</h3><p>LLVM provides support for associating stackmaps with the return address of a call. Any loop or return safepoints required by a given collector design can be modeled via calls to runtime routines, or potentially patchable call sequences. Using gcroot, all call instructions are inferred to be possible safepoints and will thus have an associated stackmap.</p><h3 id="Emitting-assembly-code-GCMetadataPrinter"><a href="#Emitting-assembly-code-GCMetadataPrinter" class="headerlink" title="Emitting assembly code: GCMetadataPrinter"></a>Emitting assembly code: <code>GCMetadataPrinter</code></h3><p>LLVM allows a plugin to print arbitrary assembly code before and after the rest of a module’s assembly code. At the end of the module, the GC can compile the LLVM stack map into assembly code. (At the beginning, this information is not yet computed.)</p><p>Since AsmWriter and CodeGen are separate components of LLVM, a separate abstract base class and registry is provided for printing assembly code, the <code>GCMetadaPrinter</code> and <code>GCMetadataPrinterRegistry</code>. The AsmWriter will look for such a subclass if the <code>GCStrategy</code> sets <code>UsesMetadata</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyGC::MyGC() &#123;</span><br><span class="line">  UsesMetadata &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This separation allows JIT-only clients to be smaller.</p><p>Note that LLVM does not currently have analogous APIs to support code generation in the JIT, nor using the object writers.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; lib&#x2F;MyGC&#x2F;MyGCPrinter.cpp - Example LLVM GC printer</span><br><span class="line"></span><br><span class="line">#include &quot;llvm&#x2F;CodeGen&#x2F;GCMetadataPrinter.h&quot;</span><br><span class="line">#include &quot;llvm&#x2F;Support&#x2F;Compiler.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace llvm;</span><br><span class="line"></span><br><span class="line">namespace &#123;</span><br><span class="line">  class LLVM_LIBRARY_VISIBILITY MyGCPrinter : public GCMetadataPrinter &#123;</span><br><span class="line">  public:</span><br><span class="line">    virtual void beginAssembly(AsmPrinter &amp;AP);</span><br><span class="line"></span><br><span class="line">    virtual void finishAssembly(AsmPrinter &amp;AP);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  GCMetadataPrinterRegistry::Add&lt;MyGCPrinter&gt;</span><br><span class="line">  X(&quot;mygc&quot;, &quot;My bespoke garbage collector.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The collector should use <code>AsmPrinter</code> to print portable assembly code. The collector itself contains the stack map for the entire module, and may access the <code>GCFunctionInfo</code> using its own <code>begin()</code> and <code>end()</code> methods. Here’s a realistic example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;llvm&#x2F;CodeGen&#x2F;AsmPrinter.h&quot;</span><br><span class="line">#include &quot;llvm&#x2F;IR&#x2F;Function.h&quot;</span><br><span class="line">#include &quot;llvm&#x2F;IR&#x2F;DataLayout.h&quot;</span><br><span class="line">#include &quot;llvm&#x2F;Target&#x2F;TargetAsmInfo.h&quot;</span><br><span class="line">#include &quot;llvm&#x2F;Target&#x2F;TargetMachine.h&quot;</span><br><span class="line"></span><br><span class="line">void MyGCPrinter::beginAssembly(AsmPrinter &amp;AP) &#123;</span><br><span class="line">  &#x2F;&#x2F; Nothing to do.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MyGCPrinter::finishAssembly(AsmPrinter &amp;AP) &#123;</span><br><span class="line">  MCStreamer &amp;OS &#x3D; AP.OutStreamer;</span><br><span class="line">  unsigned IntPtrSize &#x3D; AP.getPointerSize();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Put this in the data section.</span><br><span class="line">  OS.SwitchSection(AP.getObjFileLowering().getDataSection());</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; For each function...</span><br><span class="line">  for (iterator FI &#x3D; begin(), FE &#x3D; end(); FI !&#x3D; FE; ++FI) &#123;</span><br><span class="line">    GCFunctionInfo &amp;MD &#x3D; **FI;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; A compact GC layout. Emit this data structure:</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; struct &#123;</span><br><span class="line">    &#x2F;&#x2F;   int32_t PointCount;</span><br><span class="line">    &#x2F;&#x2F;   void *SafePointAddress[PointCount];</span><br><span class="line">    &#x2F;&#x2F;   int32_t StackFrameSize; &#x2F;&#x2F; in words</span><br><span class="line">    &#x2F;&#x2F;   int32_t StackArity;</span><br><span class="line">    &#x2F;&#x2F;   int32_t LiveCount;</span><br><span class="line">    &#x2F;&#x2F;   int32_t LiveOffsets[LiveCount];</span><br><span class="line">    &#x2F;&#x2F; &#125; __gcmap_&lt;FUNCTIONNAME&gt;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Align to address width.</span><br><span class="line">    AP.emitAlignment(IntPtrSize &#x3D;&#x3D; 4 ? 2 : 3);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Emit PointCount.</span><br><span class="line">    OS.AddComment(&quot;safe point count&quot;);</span><br><span class="line">    AP.emitInt32(MD.size());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; And each safe point...</span><br><span class="line">    for (GCFunctionInfo::iterator PI &#x3D; MD.begin(),</span><br><span class="line">                                  PE &#x3D; MD.end(); PI !&#x3D; PE; ++PI) &#123;</span><br><span class="line">      &#x2F;&#x2F; Emit the address of the safe point.</span><br><span class="line">      OS.AddComment(&quot;safe point address&quot;);</span><br><span class="line">      MCSymbol *Label &#x3D; PI-&gt;Label;</span><br><span class="line">      AP.emitLabelPlusOffset(Label&#x2F;*Hi*&#x2F;, 0&#x2F;*Offset*&#x2F;, 4&#x2F;*Size*&#x2F;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Stack information never change in safe points! Only print info from the</span><br><span class="line">    &#x2F;&#x2F; first call-site.</span><br><span class="line">    GCFunctionInfo::iterator PI &#x3D; MD.begin();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Emit the stack frame size.</span><br><span class="line">    OS.AddComment(&quot;stack frame size (in words)&quot;);</span><br><span class="line">    AP.emitInt32(MD.getFrameSize() &#x2F; IntPtrSize);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Emit stack arity, i.e. the number of stacked arguments.</span><br><span class="line">    unsigned RegisteredArgs &#x3D; IntPtrSize &#x3D;&#x3D; 4 ? 5 : 6;</span><br><span class="line">    unsigned StackArity &#x3D; MD.getFunction().arg_size() &gt; RegisteredArgs ?</span><br><span class="line">                          MD.getFunction().arg_size() - RegisteredArgs : 0;</span><br><span class="line">    OS.AddComment(&quot;stack arity&quot;);</span><br><span class="line">    AP.emitInt32(StackArity);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Emit the number of live roots in the function.</span><br><span class="line">    OS.AddComment(&quot;live root count&quot;);</span><br><span class="line">    AP.emitInt32(MD.live_size(PI));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; And for each live root...</span><br><span class="line">    for (GCFunctionInfo::live_iterator LI &#x3D; MD.live_begin(PI),</span><br><span class="line">                                       LE &#x3D; MD.live_end(PI);</span><br><span class="line">                                       LI !&#x3D; LE; ++LI) &#123;</span><br><span class="line">      &#x2F;&#x2F; Emit live root&#39;s offset within the stack frame.</span><br><span class="line">      OS.AddComment(&quot;stack index (offset &#x2F; wordsize)&quot;);</span><br><span class="line">      AP.emitInt32(LI-&gt;StackOffset);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[LLVM Doc] <a href="https://llvm.org/docs/GarbageCollection.htmls" target="_blank" rel="noopener">Garbage Collection based on LLVM</a></p><p>[Henderson2002] <a href="http://citeseer.ist.psu.edu/henderson02accurate.html" target="_blank" rel="noopener">Accurate Garbage Collection in an Uncooperative Environment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;TRANSLATION:&lt;/strong&gt; 本文内容主要包括如何在一个支持G
      
    
    </summary>
    
    
    
      <category term="Compiler" scheme="https://chinomars.com/tags/Compiler/"/>
    
      <category term="Garbage Collection" scheme="https://chinomars.com/tags/Garbage-Collection/"/>
    
      <category term="LLVM" scheme="https://chinomars.com/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>Python的交互式介绍</title>
    <link href="https://chinomars.com/2020/02/12/Python%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F/"/>
    <id>https://chinomars.com/2020/02/12/Python%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F/</id>
    <published>2020-02-11T16:20:11.000Z</published>
    <updated>2020-10-27T16:44:09.839Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>Python是一种解释型语言，通过解释器对代码进行逐行执行，一般的解释器也是这样实现，当然也存在一些优化方法，对代码进行JIT编译，提高执行速度。所以Python的REPL可以说是原生支持的。</p><p>Python语言有多种解释器，例如：</p><ul><li>CPython：C语言实现的Python解释器，一般情况下在Terminal中执行命令<code>python</code>，就会调用CPython解释器执行代码</li><li>PyPy：前面提到的通过JIT技术提升Python代码执行速度</li><li>IPython：Python的交互式解释器，底层也是通过调用CPython对代码进行解释执行</li></ul><p>回到主题REPL，我们可以以IPython为入口进行分析，进一步对CPython进行分析</p><h3 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h3><p>个人习惯，从源码出发分析。IPtyhon的github源码仓，<a href="https://github.com/ipython/ipython" target="_blank" rel="noopener">链接</a>，交互式开发的mainloop的代码在这个interactiveshell.py中，我们可以看到，IPython支持一个完整的代码块的交互式运行，采用异步的方式运行以保证一定的用户体验。一个完整的代码块，由用户输入，可以是一行完整的python代码，也可以是多行语法的代码块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_cell</span><span class="params">(self, raw_cell:str, store_history:bool, silent:bool, shell_futures:bool)</span>:</span></span><br><span class="line">        <span class="string">"""Internal method to run a complete IPython cell."""</span></span><br><span class="line">        coro = self.run_cell_async(</span><br><span class="line">            raw_cell,</span><br><span class="line">            store_history=store_history,</span><br><span class="line">            silent=silent,</span><br><span class="line">            shell_futures=shell_futures,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># run_cell_async is async, but may not actually need an eventloop.</span></span><br><span class="line">        <span class="comment"># when this is the case, we want to run it using the pseudo_sync_runner</span></span><br><span class="line">        <span class="comment"># so that code can invoke eventloops (for example via the %run , and</span></span><br><span class="line">        <span class="comment"># `%paste` magic.</span></span><br><span class="line">        <span class="keyword">if</span> self.trio_runner:</span><br><span class="line">            runner = self.trio_runner</span><br><span class="line">        <span class="keyword">elif</span> self.should_run_async(raw_cell):</span><br><span class="line">            runner = self.loop_runner</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            runner = _pseudo_sync_runner</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> runner(coro)</span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">            info = ExecutionInfo(raw_cell, store_history, silent, shell_futures)</span><br><span class="line">            result = ExecutionResult(info)</span><br><span class="line">            result.error_in_exec = e</span><br><span class="line">            self.showtraceback(running_compiled_code=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>继续分析这个run_cell_async：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run_cell_async</span><span class="params">(self, raw_cell: str, store_history=False, silent=False, shell_futures=True)</span> -&gt; ExecutionResult:</span></span><br><span class="line">        info = ExecutionInfo(</span><br><span class="line">            raw_cell, store_history, silent, shell_futures)</span><br><span class="line">        result = ExecutionResult(info)</span><br><span class="line">...</span><br><span class="line">        <span class="comment"># If any of our input transformation (input_transformer_manager or</span></span><br><span class="line">        <span class="comment"># prefilter_manager) raises an exception, we store it in this variable</span></span><br><span class="line">        <span class="comment"># so that we can display the error after logging the input and storing</span></span><br><span class="line">        <span class="comment"># it in the history.</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cell = self.transform_cell(raw_cell)</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Store raw and processed history</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Display the exception if input processing failed.</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Our own compiler remembers the __future__ environment. If we want to</span></span><br><span class="line">        <span class="comment"># run code with a separate __future__ environment, use the default</span></span><br><span class="line">        <span class="comment"># compiler</span></span><br><span class="line">        compiler = self.compile <span class="keyword">if</span> shell_futures <span class="keyword">else</span> CachingCompiler()</span><br><span class="line">        _run_async = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">with</span> self.builtin_trap:</span><br><span class="line">            cell_name = self.compile.cache(cell, self.execution_count)</span><br><span class="line">            <span class="keyword">with</span> self.display_trap:</span><br><span class="line">                <span class="comment"># Compile to bytecode</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">if</span> sys.version_info &lt; (<span class="number">3</span>,<span class="number">8</span>) <span class="keyword">and</span> self.autoawait:</span><br><span class="line">                        <span class="keyword">if</span> _should_be_async(cell):</span><br><span class="line">                            <span class="comment"># the code AST below will not be user code: we wrap it</span></span><br><span class="line">                            <span class="comment"># in an `async def`. This will likely make some AST</span></span><br><span class="line">                            <span class="comment"># transformer below miss some transform opportunity and</span></span><br><span class="line">                            <span class="comment"># introduce a small coupling to run_code (in which we</span></span><br><span class="line">                            <span class="comment"># bake some assumptions of what _ast_asyncify returns.</span></span><br><span class="line">                            <span class="comment"># they are ways around (like grafting part of the ast</span></span><br><span class="line">                            <span class="comment"># later:</span></span><br><span class="line">                            <span class="comment">#    - Here, return code_ast.body[0].body[1:-1], as well</span></span><br><span class="line">                            <span class="comment">#    as last expression in  return statement which is</span></span><br><span class="line">                            <span class="comment">#    the user code part.</span></span><br><span class="line">                            <span class="comment">#    - Let it go through the AST transformers, and graft</span></span><br><span class="line">                            <span class="comment">#    - it back after the AST transform</span></span><br><span class="line">                            <span class="comment"># But that seem unreasonable, at least while we</span></span><br><span class="line">                            <span class="comment"># do not need it.</span></span><br><span class="line">                            code_ast = _ast_asyncify(cell, <span class="string">'async-def-wrapper'</span>)</span><br><span class="line">                            _run_async = <span class="literal">True</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            code_ast = compiler.ast_parse(cell, filename=cell_name)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        code_ast = compiler.ast_parse(cell, filename=cell_name)</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment"># Apply AST transformations</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    code_ast = self.transform_ast(code_ast)</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment"># Execute the user code</span></span><br><span class="line">                interactivity = <span class="string">"none"</span> <span class="keyword">if</span> silent <span class="keyword">else</span> self.ast_node_interactivity</span><br><span class="line">                <span class="keyword">if</span> _run_async:</span><br><span class="line">                    interactivity = <span class="string">'async'</span></span><br><span class="line"></span><br><span class="line">                has_raised = <span class="keyword">await</span> self.run_ast_nodes(code_ast.body, cell_name,</span><br><span class="line">                       interactivity=interactivity, compiler=compiler, result=result)</span><br><span class="line">...</span><br><span class="line">                <span class="comment"># Reset this so later displayed values do not modify the</span></span><br><span class="line">                <span class="comment"># ExecutionResult</span></span><br><span class="line">                self.displayhook.exec_result = <span class="literal">None</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>我把一些异常处理的代码省略了，不关键的跳过。删除不关键的处理流程后我们可以分析下源码：</p><ul><li>首先是将cell代码块（raw_cell），执行历史（store_history），以及一些设置运行模式的参数（silent和shell_futures）来示例化成ExecutionInfo，然后将它塞到ExecutionResult这个方法中，做进一步的封装，方便后续进行执行过程中关键信息的存储</li><li><code>tramsform_cell</code>的工作主要是做一些行的分割以及其他处理，例如确保每一个输入cell最后有一个空行，这个也是编译器的常规操作，方便parsing的时候计算报错行号</li><li><code>_ast_asyncify</code>是一个异步方法，将输入cell（源码）解析为ast，同样其他两个分支都是将输入解析为ast，这里的分支是为了区分版本，解决版本兼容性。这里的<code>compiler</code>我们没有在IPython源码中找到定义，推测是CPython的封装，后续再分析</li><li><code>run_ast_nodes</code>也是调用了compiler的能力，下面我们就可以去CPython中进一步分析了</li></ul><p>IPython主要对CPython进行封装，将ast导入给CPython进行执行。并且，部分情况下并没有调用compiler封装的run_code方法，而是直接使用Python内置的exec()方法执行python代码，处理也比较简单。</p><h3 id="CPython"><a href="#CPython" class="headerlink" title="CPython"></a>CPython</h3><p>CPython是python解释器的c语言实现，也是Python的官方解释器。按照惯例我们还是从源码入手，cpython托管在github上，<a href="https://github.com/python/cpython" target="_blank" rel="noopener">项目链接</a>。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>首先从main函数出发，找到<code>Programs/python.c</code>中的main函数，在进入到repl loop之前，我们快速过一下执行流程。当然，对于c/c++项目而言，最万能的方式还是通过调试，一步一步地借助断点和查看调用栈来分析。在只关注一个具体的功能的时候，个人还是比较偏向于直接看源码，聚焦关键的函数。</p><p>执行流程：</p><ul><li><code>Programs/python.c:16 =&gt; Py_BytesMain</code></li><li><code>Modules/main.c:679 =&gt; pymain_main</code></li><li><code>Modules/main.c:627 Py_RunMain =&gt; pymain_run_python</code></li></ul><p>到pymain_run_python()函数，我们可以具体看一下这个函数里的构成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pymain_run_python(<span class="keyword">int</span> *exitcode)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">config</span>-&gt;run_command) &#123;</span><br><span class="line">        *exitcode = pymain_run_command(<span class="built_in">config</span>-&gt;run_command, &amp;cf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">config</span>-&gt;run_module) &#123;</span><br><span class="line">        *exitcode = pymain_run_module(<span class="built_in">config</span>-&gt;run_module, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (main_importer_path != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *exitcode = pymain_run_module(<span class="string">L"__main__"</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">config</span>-&gt;run_filename != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *exitcode = pymain_run_file(<span class="built_in">config</span>, &amp;cf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        *exitcode = pymain_run_stdin(<span class="built_in">config</span>, &amp;cf);</span><br><span class="line">    &#125;</span><br><span class="line">    pymain_repl(<span class="built_in">config</span>, &amp;cf, exitcode);</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，通过函数最开始构建的运行环境配置（config），来决定后续的分支：</p><ul><li>run_command分支：调用<code>pymain_run_command()</code>函数，来执行命令</li><li>run_module分支：调用<code>pymain_run_module()</code>函数，运行一个python模块</li><li>run_filename分支：调用<code>pymain_run_file()</code>函数，运行一个python文件</li><li>其他：调用<code>pymain_run_stdin()</code>函数，来执行一个标准输入</li><li>最后：调用<code>pymain_repl()</code>函数，启动repl</li></ul><p>上述执行分支中，估计大家对于最后两个分支（<strong>其他</strong>和<strong>最后</strong>）会感到十分疑惑，看起来逻辑有重复，<strong>其他</strong>分支中，调用<code>pymain_run_stdin()</code>函数后，再启动repl。实际上最后两个分支最终调用的函数都是一样的：</p><ul><li><code>pymain_run_stdin()</code>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">pymain_run_stdin(PyConfig *<span class="built_in">config</span>, PyCompilerFlags *cf)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">run</span> = PyRun_AnyFileExFlags(<span class="built_in">stdin</span>, <span class="string">"&lt;stdin&gt;"</span>, <span class="number">0</span>, cf);</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">run</span> != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>pymain_repl()</code>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pymain_repl(PyConfig *<span class="built_in">config</span>, PyCompilerFlags *cf, <span class="keyword">int</span> *exitcode)</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">int</span> res = PyRun_AnyFileFlags(<span class="built_in">stdin</span>, <span class="string">"&lt;stdin&gt;"</span>, cf);</span><br><span class="line">    *exitcode = (res != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，在<code>pymain_repl()</code>中调用的<code>PyRun_AnyFileFlags()</code>，在<code>include/pythonrun.h</code>中定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyRun_AnyFileFlags(fp, name, flags) \</span></span><br><span class="line">    PyRun_AnyFileExFlags(fp, name, <span class="number">0</span>, flags)</span><br></pre></td></tr></table></figure><p>是一毛一样的呢。最终就执行到了我们的重头戏：<code>Python/pythonrun.c:91 PyRun_InteractiveLoopFlags()</code></p><h4 id="interactive-loop"><a href="#interactive-loop" class="headerlink" title="interactive loop"></a>interactive loop</h4><p><code>PyRun_InteractiveLoopFlags(stdin, &quot;&lt;stdin&gt;&quot;, 0, cf)</code>中，从<code>stdin</code>标准输入流中读取用户输入，进行执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">PyRun_InteractiveLoopFlags(FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *filename_str, PyCompilerFlags *flags)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ret = PyRun_InteractiveOneObjectEx(fp, filename, flags);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; PyErr_Occurred()) &#123;</span><br><span class="line">...</span><br><span class="line">            PyErr_Print();</span><br><span class="line">            flush_io();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nomem_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (ret != E_EOF);</span><br><span class="line">    Py_DECREF(filename);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>PyRun_InteractiveOneObjectEx()</code>函数执行用户输入。</p><p>我们可以看到对于一个Python Object的执行流程如下：</p><ul><li><code>_PyUnicode_FromId</code>：造一个modulename</li><li><code>_PySys_GetObjectId</code>：从stdin中读取用户输入</li><li><code>PyImport_AddModuleObject</code>：加载import模块</li><li><code>run_mod</code>：运行module</li></ul><p><code>run_mod()</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">run_mod(mod_ty mod, PyObject *filename, PyObject *globals, PyObject *locals,</span><br><span class="line">            PyCompilerFlags *flags, PyArena *arena)</span><br><span class="line">&#123;</span><br><span class="line">    PyCodeObject *co;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    co = PyAST_CompileObject(mod, filename, flags, <span class="number">-1</span>, arena);</span><br><span class="line">    <span class="keyword">if</span> (co == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PySys_Audit(<span class="string">"exec"</span>, <span class="string">"O"</span>, co) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Py_DECREF(co);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v = run_eval_code_obj(co, globals, locals);</span><br><span class="line">    Py_DECREF(co);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先将python moduleParse成AST（调用<code>PyAST_CompileObject()</code>函数），再编译成Python的ByteCode，最后塞给<code>run_eval_code_obj()</code>函数进行执行。</p><p>基本上repl的执行流程就讲完了，有点困了，有（bu）时（xiang）间（nong）再细化补充，欢迎留言。</p><p>源码分析地比较粗糙，找到一片详细debug，介绍cpython中的编译执行流程的博客，见最后一片参考文章（Internals of CPython），写得比较详细，甚至还简单介绍了gdb的使用方式，很贴心。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.liaoxuefeng.com/wiki/897692888725344/966138843228672" target="_blank" rel="noopener">Python解释器</a></p><p><a href="https://github.com/ipython/ipython/blob/master/IPython/core/interactiveshell.py" target="_blank" rel="noopener">interactiveshell.py</a></p><p><a href="https://github.com/python/cpython/blob/master/Modules/main.c" target="_blank" rel="noopener">Modules/main.c</a></p><p><a href="https://github.com/python/cpython/blob/master/Python/pythonrun.c" target="_blank" rel="noopener">Python/pythonrun.c</a></p><p><a href="https://hackmd.io/@xff9N3eQTLSL4Trq-6setg/ByMHBMjFe?type=view" target="_blank" rel="noopener">Internals of CPython</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h3&gt;&lt;p&gt;Python是一种解释型语言，通过解释器对代码进行逐行执行，一般的解释器也是这样实现，当然也存在一些优化方法，对代码进行JIT编译，提高执行
      
    
    </summary>
    
    
    
      <category term="Compiler" scheme="https://chinomars.com/tags/Compiler/"/>
    
      <category term="Python" scheme="https://chinomars.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Swift REPL模式介绍</title>
    <link href="https://chinomars.com/2020/02/07/Swift-REPL%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/"/>
    <id>https://chinomars.com/2020/02/07/Swift-REPL%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-02-07T08:45:43.000Z</published>
    <updated>2020-10-27T16:43:39.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h3><p>在IR层面支持REPL，提供swift解释器，swift提供了编译器runtime，提供基础的词法分析、语法分析、IR生成能力，并可基于llvm ir进行表达式eval，通过JIT的方式在解释器中支持REPL。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ol><li><p>头文件：<code>include/swift/Immediate/Immediate.h</code>，包含两个接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RunImmediately</span><span class="params">(CompilerInstance &amp;CI, <span class="keyword">const</span> ProcessCmdLine &amp;CmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> IRGenOptions &amp;IRGenOpts, <span class="keyword">const</span> SILOptions &amp;SILOpts,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;SILModule&gt; &amp;&amp;SM)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runREPL</span><span class="params">(CompilerInstance &amp;CI, <span class="keyword">const</span> ProcessCmdLine &amp;CmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">bool</span> ParseStdlib)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>RunImmediately方法用于基于<strong>SIL（Swift Intermediate Language）</strong>，立即Eval当前IR Module，相当于是解释器</li><li>runREPL方法提供给FrontendTool.cpp前端逻辑进行调用，作为REPL的main loop</li></ul></li><li><p>源码文件：Immediate.cpp</p></li></ol><p>实现几个功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">loadSwiftRuntime</span><span class="params">(ArrayRef&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; runtimeLibPaths)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">tryLoadLibraries</span><span class="params">(ArrayRef&lt;LinkLibrary&gt; LinkLibraries,</span></span></span><br><span class="line"><span class="function"><span class="params">                      SearchPathOptions SearchPathOpts,</span></span></span><br><span class="line"><span class="function"><span class="params">                      DiagnosticEngine &amp;Diags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">linkLLVMModules</span><span class="params">(llvm::Module *Module,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;llvm::Module&gt; SubModule)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">autolinkImportedModules</span><span class="params">(ModuleDecl *M, <span class="keyword">const</span> IRGenOptions &amp;IRGenOpts)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swift::RunImmediately</span><span class="params">(CompilerInstance &amp;CI,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> ProcessCmdLine &amp;CmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> IRGenOptions &amp;IRGenOpts,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> SILOptions &amp;SILOpts,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;SILModule&gt; &amp;&amp;SM)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>加载swift编译器runtime：swiftCore</li><li>llvm ir module间合并</li><li>import module的支持</li><li>RunImmediately：将input翻译成llvm ir，调用<code>llvm::ExecutionEngine</code>直接执行llvm ir</li></ul><ol start="3"><li>源码文件：REPL.cpp</li></ol><p>REPL的主函数，从Frontend.cpp进来，主要由一个读取用户input的main loop，对每个输入进行处理。依赖histedit的支持</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p><a href="https://blog.csdn.net/weixin_43740680/article/details/98234795" target="_blank" rel="noopener">What’s REPL</a></p><p><a href="https://github.com/apple/swift/blob/master/lib/Immediate/Immediate.cpp" target="_blank" rel="noopener">Source Code Immediate.cpp</a></p><p><a href="https://github.com/apple/swift/blob/master/lib/Immediate/REPL.cpp" target="_blank" rel="noopener">Source Code REPL.cpp</a></p><p><a href="http://ftp.netbsd.org/pub/NetBSD/NetBSD-current/src/lib/libedit/histedit.h" target="_blank" rel="noopener">histedit.h: Line editor and history interface.</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;技术路线&quot;&gt;&lt;a href=&quot;#技术路线&quot; class=&quot;headerlink&quot; title=&quot;技术路线&quot;&gt;&lt;/a&gt;技术路线&lt;/h3&gt;&lt;p&gt;在IR层面支持REPL，提供swift解释器，swift提供了编译器runtime，提供基础的词法分析、语法分析、IR生成能
      
    
    </summary>
    
    
    
      <category term="Compiler" scheme="https://chinomars.com/tags/Compiler/"/>
    
      <category term="Swift" scheme="https://chinomars.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>基于Hexo和github page搭建个人博客</title>
    <link href="https://chinomars.com/2020/01/29/%E5%9F%BA%E4%BA%8EHexo%E5%92%8Cgithub-page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://chinomars.com/2020/01/29/%E5%9F%BA%E4%BA%8EHexo%E5%92%8Cgithub-page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-01-29T11:46:47.000Z</published>
    <updated>2020-01-30T06:26:03.234Z</updated>
    
    <content type="html"><![CDATA[<p>倒腾过好几次个人主页，但个人原创文章并不多，总是要么在换模板的路上，要不就是在换框架的路上，终于乐此而疲了。这次换个人主页之后还是要静下心来多写文章才是。这篇文章用于答谢Hexo和Archer主题的作者，hexo是到目前为止用过的最好用的博客框架，archer主题模板是目前个人比较喜欢的一款模版。</p><p>废话不多说，按照个人习惯，分四段简单介绍下如何基于Hexo和Github Page搭建个人主页。</p><blockquote><p>本文不严格区分*nix系统和windows系统，所有命令均可在terminal或者gitbash中执行。</p></blockquote><h2 id="0x00-准备"><a href="#0x00-准备" class="headerlink" title="0x00 准备"></a>0x00 准备</h2><p>hexo是一个静态站点生成工具，集创建（初始化站点）、开发（指的是写博客）、发布博客文章功能于一体，十分方便。</p><p>搭建博客站点先准备以下平台的账号和开发环境：</p><ul><li><p>注册github账户，<a href="https://github.com/" target="_blank" rel="noopener">链接</a></p></li><li><p>安装git，并在github账户中配置sshkey：*nix系统一般自带git，windows系统安装gitbash，<a href="https://gitforwindows.org/" target="_blank" rel="noopener">下载地址</a></p></li><li><p>配置sshkey：</p><ul><li><p>生成sshkey：*nix系统中打开terminal，windows系统中打开gitbash，参考<a href="https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh" target="_blank" rel="noopener">教程</a>，执行以下命令，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~ &amp;&amp; ssh-keygen -t rsa -b 4096 -C <span class="string">"your_email@example.com"</span> <span class="comment"># your_email@example.com替换为你注册github的邮箱，可以一直按回车生成默认的文件名，方便阅读后续的步骤</span></span><br></pre></td></tr></table></figure></li><li><p>执行以下命令，拷贝出你的public key，将屏幕中输出的公钥内容<code>ctrl+c</code>进行拷贝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh/ &amp;&amp; cat id_rsa.pub <span class="comment"># 这里的id_rsa.pub为上一步生成的密钥对中的公钥</span></span><br></pre></td></tr></table></figure></li><li><p>打开github中配置sshkey的界面，<a href="https://github.com/settings/keys" target="_blank" rel="noopener">链接</a>，选择<code>New SSH key</code>，把拷贝的公钥配置上去即可。</p></li></ul></li><li><p>安装Nodejs，<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">下载地址</a>，安装成功后会同时安装好node和npm两个工具，并为npm配置国内源，例如配置淘宝源可以执行下述命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li><p>安装hexo，执行下述命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g <span class="comment"># install hexo</span></span><br><span class="line">hexo -v <span class="comment"># check whether successfully installed</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="0x01-初始化站点"><a href="#0x01-初始化站点" class="headerlink" title="0x01 初始化站点"></a>0x01 初始化站点</h2><p>执行以下命令来初始化博客站点，会创建一个新的目录，以blog-dev为例，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog-dev</span><br></pre></td></tr></table></figure><p>待命令执行完毕，会新建一个blog-dev目录，进入该目录中，我们可以看到以下目录树：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">blog-dev</span><br><span class="line">├── _config.yml        <span class="comment">#---------------- 站点配置文件</span></span><br><span class="line">├── node_modules       <span class="comment">#---------------- npm安装包本地保存目录</span></span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json       <span class="comment">#---------------- 依赖包配置文件</span></span><br><span class="line">├── scaffolds</span><br><span class="line">├── <span class="built_in">source</span>             <span class="comment">#---------------- 博客文章保存目录</span></span><br><span class="line">└── themes             <span class="comment">#---------------- 博客主题保存目录</span></span><br></pre></td></tr></table></figure><p>此时，进入到blog-dev目录，可以执行hexo的相关参数及命令，可以进行站点的管理，简单介绍如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment"># 清除缓存</span></span><br><span class="line">hexo generate <span class="comment"># 生成网站静态文件</span></span><br><span class="line">hexo server <span class="comment"># 启动本地调试模式，默认可以打开localhost:4000查看网站效果</span></span><br><span class="line">hexo deploy <span class="comment"># 发布到GitHub Page，第0x11节会具体介绍</span></span><br></pre></td></tr></table></figure><p>hexo还有一个非常方便的点是主题套用十分方便，将想要的模板下载下来，放到themes目录下，然后修改_config.yml文件中的theme字段，改为下载下来的主题目录名即可。主题可以在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方网站下载</a>，也可以自行从各种渠道获取。</p><h2 id="0x10-创建github-page"><a href="#0x10-创建github-page" class="headerlink" title="0x10 创建github page"></a>0x10 创建github page</h2><p>本节内容大家应该都比较熟悉，创建作为个人主页用的github page，必须将仓名命名为username.github.com，经过测试，仓名中的username与你的github账号名可以不区分大小写。</p><p>这部分教程我想偷懒跳过了，可以自行查看<a href="https://pages.github.com/" target="_blank" rel="noopener">官方教程</a>。</p><h2 id="0x11-预览和发布"><a href="#0x11-预览和发布" class="headerlink" title="0x11 预览和发布"></a>0x11 预览和发布</h2><p>在blog-dev目录下执行<code>hexo new &#39;博客标题&#39;</code>即可创建一篇新的博客，使用markdown语法进行编辑。</p><p>编辑完毕之后，执行下述命令，可以启动一个本地的临时服务器进行预览：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server <span class="comment"># 启动本地预览服务</span></span><br></pre></td></tr></table></figure><p>在浏览器中打开<code>localhost:4000</code>，即可预览你的博客。</p><p>配置blog-dev的发布路径，编辑blog-dev/_config.yml文件，一般在文件末尾，有一个deploy字段，把第三节创建的github page仓库路径配置上去即可，如果deploy字段下只有一个type，则手动添加其他字段（注意yml文件遵从yaml格式缩紧）。例如我的配置就是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span>                                                                                                          </span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/ChinoMars/chinomars.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>依次执行下述命令，即可发布你的静态站点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment"># 清除缓存</span></span><br><span class="line">hexo generate <span class="comment"># 生成站点的静态文件</span></span><br><span class="line">hexo deploy <span class="comment"># 自动push到github page所在的master分支，进行发布</span></span><br></pre></td></tr></table></figure><p>最后，可以打开网址：<code>https://username.github.io</code>即可查看个人的站点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;倒腾过好几次个人主页，但个人原创文章并不多，总是要么在换模板的路上，要不就是在换框架的路上，终于乐此而疲了。这次换个人主页之后还是要静下心来多写文章才是。这篇文章用于答谢Hexo和Archer主题的作者，hexo是到目前为止用过的最好用的博客框架，archer主题模板是目前
      
    
    </summary>
    
    
    
      <category term="小白" scheme="https://chinomars.com/tags/%E5%B0%8F%E7%99%BD/"/>
    
  </entry>
  
</feed>
